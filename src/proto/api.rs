// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/tensorboardrs/proto/api.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct Experiment {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub user: ::std::string::String,
    pub time_created_secs: f64,
    pub hparam_infos: ::protobuf::RepeatedField<HParamInfo>,
    pub metric_infos: ::protobuf::RepeatedField<MetricInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Experiment {
    fn default() -> &'a Experiment {
        <Experiment as ::protobuf::Message>::default_instance()
    }
}

impl Experiment {
    pub fn new() -> Experiment {
        ::std::default::Default::default()
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 1;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string user = 2;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // double time_created_secs = 3;


    pub fn get_time_created_secs(&self) -> f64 {
        self.time_created_secs
    }
    pub fn clear_time_created_secs(&mut self) {
        self.time_created_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time_created_secs(&mut self, v: f64) {
        self.time_created_secs = v;
    }

    // repeated .tensorboardrs.hparam.HParamInfo hparam_infos = 4;


    pub fn get_hparam_infos(&self) -> &[HParamInfo] {
        &self.hparam_infos
    }
    pub fn clear_hparam_infos(&mut self) {
        self.hparam_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_hparam_infos(&mut self, v: ::protobuf::RepeatedField<HParamInfo>) {
        self.hparam_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hparam_infos(&mut self) -> &mut ::protobuf::RepeatedField<HParamInfo> {
        &mut self.hparam_infos
    }

    // Take field
    pub fn take_hparam_infos(&mut self) -> ::protobuf::RepeatedField<HParamInfo> {
        ::std::mem::replace(&mut self.hparam_infos, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorboardrs.hparam.MetricInfo metric_infos = 5;


    pub fn get_metric_infos(&self) -> &[MetricInfo] {
        &self.metric_infos
    }
    pub fn clear_metric_infos(&mut self) {
        self.metric_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_infos(&mut self, v: ::protobuf::RepeatedField<MetricInfo>) {
        self.metric_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_infos(&mut self) -> &mut ::protobuf::RepeatedField<MetricInfo> {
        &mut self.metric_infos
    }

    // Take field
    pub fn take_metric_infos(&mut self) -> ::protobuf::RepeatedField<MetricInfo> {
        ::std::mem::replace(&mut self.metric_infos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Experiment {
    fn is_initialized(&self) -> bool {
        for v in &self.hparam_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metric_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.time_created_secs = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hparam_infos)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.description);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        if self.time_created_secs != 0. {
            my_size += 9;
        }
        for value in &self.hparam_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metric_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(1, &self.description)?;
        }
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        if self.time_created_secs != 0. {
            os.write_double(3, self.time_created_secs)?;
        }
        for v in &self.hparam_infos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metric_infos {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Experiment {
        Experiment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Experiment| { &m.name },
                    |m: &mut Experiment| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Experiment| { &m.description },
                    |m: &mut Experiment| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    |m: &Experiment| { &m.user },
                    |m: &mut Experiment| { &mut m.user },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "time_created_secs",
                    |m: &Experiment| { &m.time_created_secs },
                    |m: &mut Experiment| { &mut m.time_created_secs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HParamInfo>>(
                    "hparam_infos",
                    |m: &Experiment| { &m.hparam_infos },
                    |m: &mut Experiment| { &mut m.hparam_infos },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricInfo>>(
                    "metric_infos",
                    |m: &Experiment| { &m.metric_infos },
                    |m: &mut Experiment| { &mut m.metric_infos },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Experiment>(
                    "Experiment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Experiment {
        static mut instance: ::protobuf::lazy::Lazy<Experiment> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Experiment::new)
        }
    }
}

impl ::protobuf::Clear for Experiment {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.user.clear();
        self.time_created_secs = 0.;
        self.hparam_infos.clear();
        self.metric_infos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Experiment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Experiment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HParamInfo {
    // message fields
    pub name: ::std::string::String,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub field_type: DataType,
    // message oneof groups
    pub domain: ::std::option::Option<HParamInfo_oneof_domain>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HParamInfo {
    fn default() -> &'a HParamInfo {
        <HParamInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HParamInfo_oneof_domain {
    domain_discrete(::protobuf::well_known_types::ListValue),
    domain_interval(Interval),
}

impl HParamInfo {
    pub fn new() -> HParamInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .tensorboardrs.hparam.DataType type = 4;


    pub fn get_field_type(&self) -> DataType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = DataType::DATA_TYPE_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DataType) {
        self.field_type = v;
    }

    // .google.protobuf.ListValue domain_discrete = 5;


    pub fn get_domain_discrete(&self) -> &::protobuf::well_known_types::ListValue {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(ref v)) => v,
            _ => ::protobuf::well_known_types::ListValue::default_instance(),
        }
    }
    pub fn clear_domain_discrete(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain_discrete(&self) -> bool {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_domain_discrete(&mut self, v: ::protobuf::well_known_types::ListValue) {
        self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_domain_discrete(&mut self) -> &mut ::protobuf::well_known_types::ListValue {
        if let ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(_)) = self.domain {
        } else {
            self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(::protobuf::well_known_types::ListValue::new()));
        }
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_domain_discrete(&mut self) -> ::protobuf::well_known_types::ListValue {
        if self.has_domain_discrete() {
            match self.domain.take() {
                ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::ListValue::new()
        }
    }

    // .tensorboardrs.hparam.Interval domain_interval = 6;


    pub fn get_domain_interval(&self) -> &Interval {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(ref v)) => v,
            _ => Interval::default_instance(),
        }
    }
    pub fn clear_domain_interval(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain_interval(&self) -> bool {
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_domain_interval(&mut self, v: Interval) {
        self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(v))
    }

    // Mutable pointer to the field.
    pub fn mut_domain_interval(&mut self) -> &mut Interval {
        if let ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(_)) = self.domain {
        } else {
            self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(Interval::new()));
        }
        match self.domain {
            ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_domain_interval(&mut self) -> Interval {
        if self.has_domain_interval() {
            match self.domain.take() {
                ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(v)) => v,
                _ => panic!(),
            }
        } else {
            Interval::new()
        }
    }
}

impl ::protobuf::Message for HParamInfo {
    fn is_initialized(&self) -> bool {
        if let Some(HParamInfo_oneof_domain::domain_discrete(ref v)) = self.domain {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HParamInfo_oneof_domain::domain_interval(ref v)) = self.domain {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_discrete(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.domain = ::std::option::Option::Some(HParamInfo_oneof_domain::domain_interval(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if self.field_type != DataType::DATA_TYPE_UNSET {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        if let ::std::option::Option::Some(ref v) = self.domain {
            match v {
                &HParamInfo_oneof_domain::domain_discrete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HParamInfo_oneof_domain::domain_interval(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if self.field_type != DataType::DATA_TYPE_UNSET {
            os.write_enum(4, self.field_type.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.domain {
            match v {
                &HParamInfo_oneof_domain::domain_discrete(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HParamInfo_oneof_domain::domain_interval(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HParamInfo {
        HParamInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &HParamInfo| { &m.name },
                    |m: &mut HParamInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "display_name",
                    |m: &HParamInfo| { &m.display_name },
                    |m: &mut HParamInfo| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &HParamInfo| { &m.description },
                    |m: &mut HParamInfo| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataType>>(
                    "type",
                    |m: &HParamInfo| { &m.field_type },
                    |m: &mut HParamInfo| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::ListValue>(
                    "domain_discrete",
                    HParamInfo::has_domain_discrete,
                    HParamInfo::get_domain_discrete,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Interval>(
                    "domain_interval",
                    HParamInfo::has_domain_interval,
                    HParamInfo::get_domain_interval,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HParamInfo>(
                    "HParamInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HParamInfo {
        static mut instance: ::protobuf::lazy::Lazy<HParamInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HParamInfo::new)
        }
    }
}

impl ::protobuf::Clear for HParamInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.field_type = DataType::DATA_TYPE_UNSET;
        self.domain = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HParamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HParamInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Interval {
    // message fields
    pub min_value: f64,
    pub max_value: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Interval {
    fn default() -> &'a Interval {
        <Interval as ::protobuf::Message>::default_instance()
    }
}

impl Interval {
    pub fn new() -> Interval {
        ::std::default::Default::default()
    }

    // double min_value = 1;


    pub fn get_min_value(&self) -> f64 {
        self.min_value
    }
    pub fn clear_min_value(&mut self) {
        self.min_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f64) {
        self.min_value = v;
    }

    // double max_value = 2;


    pub fn get_max_value(&self) -> f64 {
        self.max_value
    }
    pub fn clear_max_value(&mut self) {
        self.max_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_value(&mut self, v: f64) {
        self.max_value = v;
    }
}

impl ::protobuf::Message for Interval {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.min_value = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_value != 0. {
            my_size += 9;
        }
        if self.max_value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_value != 0. {
            os.write_double(1, self.min_value)?;
        }
        if self.max_value != 0. {
            os.write_double(2, self.max_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Interval {
        Interval::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "min_value",
                    |m: &Interval| { &m.min_value },
                    |m: &mut Interval| { &mut m.min_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "max_value",
                    |m: &Interval| { &m.max_value },
                    |m: &mut Interval| { &mut m.max_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Interval>(
                    "Interval",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Interval {
        static mut instance: ::protobuf::lazy::Lazy<Interval> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Interval::new)
        }
    }
}

impl ::protobuf::Clear for Interval {
    fn clear(&mut self) {
        self.min_value = 0.;
        self.max_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Interval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Interval {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricName {
    // message fields
    pub group: ::std::string::String,
    pub tag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricName {
    fn default() -> &'a MetricName {
        <MetricName as ::protobuf::Message>::default_instance()
    }
}

impl MetricName {
    pub fn new() -> MetricName {
        ::std::default::Default::default()
    }

    // string group = 1;


    pub fn get_group(&self) -> &str {
        &self.group
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        &mut self.group
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.group, ::std::string::String::new())
    }

    // string tag = 2;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetricName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.group.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.group);
        }
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.group.is_empty() {
            os.write_string(1, &self.group)?;
        }
        if !self.tag.is_empty() {
            os.write_string(2, &self.tag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricName {
        MetricName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group",
                    |m: &MetricName| { &m.group },
                    |m: &mut MetricName| { &mut m.group },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tag",
                    |m: &MetricName| { &m.tag },
                    |m: &mut MetricName| { &mut m.tag },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricName>(
                    "MetricName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetricName {
        static mut instance: ::protobuf::lazy::Lazy<MetricName> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MetricName::new)
        }
    }
}

impl ::protobuf::Clear for MetricName {
    fn clear(&mut self) {
        self.group.clear();
        self.tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricName {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricInfo {
    // message fields
    pub name: ::protobuf::SingularPtrField<MetricName>,
    pub display_name: ::std::string::String,
    pub description: ::std::string::String,
    pub dataset_type: DatasetType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricInfo {
    fn default() -> &'a MetricInfo {
        <MetricInfo as ::protobuf::Message>::default_instance()
    }
}

impl MetricInfo {
    pub fn new() -> MetricInfo {
        ::std::default::Default::default()
    }

    // .tensorboardrs.hparam.MetricName name = 1;


    pub fn get_name(&self) -> &MetricName {
        self.name.as_ref().unwrap_or_else(|| MetricName::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: MetricName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut MetricName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> MetricName {
        self.name.take().unwrap_or_else(|| MetricName::new())
    }

    // string display_name = 3;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string description = 4;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .tensorboardrs.hparam.DatasetType dataset_type = 5;


    pub fn get_dataset_type(&self) -> DatasetType {
        self.dataset_type
    }
    pub fn clear_dataset_type(&mut self) {
        self.dataset_type = DatasetType::DATASET_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_dataset_type(&mut self, v: DatasetType) {
        self.dataset_type = v;
    }
}

impl ::protobuf::Message for MetricInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dataset_type, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.display_name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        if self.dataset_type != DatasetType::DATASET_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(5, self.dataset_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(3, &self.display_name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        if self.dataset_type != DatasetType::DATASET_UNKNOWN {
            os.write_enum(5, self.dataset_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricInfo {
        MetricInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                    "name",
                    |m: &MetricInfo| { &m.name },
                    |m: &mut MetricInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "display_name",
                    |m: &MetricInfo| { &m.display_name },
                    |m: &mut MetricInfo| { &mut m.display_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &MetricInfo| { &m.description },
                    |m: &mut MetricInfo| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatasetType>>(
                    "dataset_type",
                    |m: &MetricInfo| { &m.dataset_type },
                    |m: &mut MetricInfo| { &mut m.dataset_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricInfo>(
                    "MetricInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetricInfo {
        static mut instance: ::protobuf::lazy::Lazy<MetricInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MetricInfo::new)
        }
    }
}

impl ::protobuf::Clear for MetricInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.display_name.clear();
        self.description.clear();
        self.dataset_type = DatasetType::DATASET_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionGroup {
    // message fields
    pub name: ::std::string::String,
    pub hparams: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value>,
    pub metric_values: ::protobuf::RepeatedField<MetricValue>,
    pub sessions: ::protobuf::RepeatedField<Session>,
    pub monitor_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionGroup {
    fn default() -> &'a SessionGroup {
        <SessionGroup as ::protobuf::Message>::default_instance()
    }
}

impl SessionGroup {
    pub fn new() -> SessionGroup {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .tensorboardrs.hparam.SessionGroup.HparamsEntry hparams = 2;


    pub fn get_hparams(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value> {
        &self.hparams
    }
    pub fn clear_hparams(&mut self) {
        self.hparams.clear();
    }

    // Param is passed by value, moved
    pub fn set_hparams(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value>) {
        self.hparams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hparams(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value> {
        &mut self.hparams
    }

    // Take field
    pub fn take_hparams(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Value> {
        ::std::mem::replace(&mut self.hparams, ::std::collections::HashMap::new())
    }

    // repeated .tensorboardrs.hparam.MetricValue metric_values = 3;


    pub fn get_metric_values(&self) -> &[MetricValue] {
        &self.metric_values
    }
    pub fn clear_metric_values(&mut self) {
        self.metric_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_values(&mut self, v: ::protobuf::RepeatedField<MetricValue>) {
        self.metric_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_values(&mut self) -> &mut ::protobuf::RepeatedField<MetricValue> {
        &mut self.metric_values
    }

    // Take field
    pub fn take_metric_values(&mut self) -> ::protobuf::RepeatedField<MetricValue> {
        ::std::mem::replace(&mut self.metric_values, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorboardrs.hparam.Session sessions = 4;


    pub fn get_sessions(&self) -> &[Session] {
        &self.sessions
    }
    pub fn clear_sessions(&mut self) {
        self.sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_sessions(&mut self, v: ::protobuf::RepeatedField<Session>) {
        self.sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sessions(&mut self) -> &mut ::protobuf::RepeatedField<Session> {
        &mut self.sessions
    }

    // Take field
    pub fn take_sessions(&mut self) -> ::protobuf::RepeatedField<Session> {
        ::std::mem::replace(&mut self.sessions, ::protobuf::RepeatedField::new())
    }

    // string monitor_url = 5;


    pub fn get_monitor_url(&self) -> &str {
        &self.monitor_url
    }
    pub fn clear_monitor_url(&mut self) {
        self.monitor_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitor_url(&mut self, v: ::std::string::String) {
        self.monitor_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monitor_url(&mut self) -> &mut ::std::string::String {
        &mut self.monitor_url
    }

    // Take field
    pub fn take_monitor_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.monitor_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SessionGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.metric_values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sessions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(wire_type, is, &mut self.hparams)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_values)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sessions)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.monitor_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(2, &self.hparams);
        for value in &self.metric_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.monitor_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.monitor_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(2, &self.hparams, os)?;
        for v in &self.metric_values {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sessions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.monitor_url.is_empty() {
            os.write_string(5, &self.monitor_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionGroup {
        SessionGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &SessionGroup| { &m.name },
                    |m: &mut SessionGroup| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Value>>(
                    "hparams",
                    |m: &SessionGroup| { &m.hparams },
                    |m: &mut SessionGroup| { &mut m.hparams },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricValue>>(
                    "metric_values",
                    |m: &SessionGroup| { &m.metric_values },
                    |m: &mut SessionGroup| { &mut m.metric_values },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Session>>(
                    "sessions",
                    |m: &SessionGroup| { &m.sessions },
                    |m: &mut SessionGroup| { &mut m.sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "monitor_url",
                    |m: &SessionGroup| { &m.monitor_url },
                    |m: &mut SessionGroup| { &mut m.monitor_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionGroup>(
                    "SessionGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SessionGroup {
        static mut instance: ::protobuf::lazy::Lazy<SessionGroup> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SessionGroup::new)
        }
    }
}

impl ::protobuf::Clear for SessionGroup {
    fn clear(&mut self) {
        self.name.clear();
        self.hparams.clear();
        self.metric_values.clear();
        self.sessions.clear();
        self.monitor_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricValue {
    // message fields
    pub name: ::protobuf::SingularPtrField<MetricName>,
    pub value: f64,
    pub training_step: i32,
    pub wall_time_secs: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricValue {
    fn default() -> &'a MetricValue {
        <MetricValue as ::protobuf::Message>::default_instance()
    }
}

impl MetricValue {
    pub fn new() -> MetricValue {
        ::std::default::Default::default()
    }

    // .tensorboardrs.hparam.MetricName name = 1;


    pub fn get_name(&self) -> &MetricName {
        self.name.as_ref().unwrap_or_else(|| MetricName::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: MetricName) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut MetricName {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> MetricName {
        self.name.take().unwrap_or_else(|| MetricName::new())
    }

    // double value = 2;


    pub fn get_value(&self) -> f64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = v;
    }

    // int32 training_step = 3;


    pub fn get_training_step(&self) -> i32 {
        self.training_step
    }
    pub fn clear_training_step(&mut self) {
        self.training_step = 0;
    }

    // Param is passed by value, moved
    pub fn set_training_step(&mut self, v: i32) {
        self.training_step = v;
    }

    // double wall_time_secs = 4;


    pub fn get_wall_time_secs(&self) -> f64 {
        self.wall_time_secs
    }
    pub fn clear_wall_time_secs(&mut self) {
        self.wall_time_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wall_time_secs(&mut self, v: f64) {
        self.wall_time_secs = v;
    }
}

impl ::protobuf::Message for MetricValue {
    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.training_step = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.wall_time_secs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0. {
            my_size += 9;
        }
        if self.training_step != 0 {
            my_size += ::protobuf::rt::value_size(3, self.training_step, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.wall_time_secs != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        if self.training_step != 0 {
            os.write_int32(3, self.training_step)?;
        }
        if self.wall_time_secs != 0. {
            os.write_double(4, self.wall_time_secs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricValue {
        MetricValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                    "name",
                    |m: &MetricValue| { &m.name },
                    |m: &mut MetricValue| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "value",
                    |m: &MetricValue| { &m.value },
                    |m: &mut MetricValue| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "training_step",
                    |m: &MetricValue| { &m.training_step },
                    |m: &mut MetricValue| { &mut m.training_step },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "wall_time_secs",
                    |m: &MetricValue| { &m.wall_time_secs },
                    |m: &mut MetricValue| { &mut m.wall_time_secs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricValue>(
                    "MetricValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetricValue {
        static mut instance: ::protobuf::lazy::Lazy<MetricValue> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MetricValue::new)
        }
    }
}

impl ::protobuf::Clear for MetricValue {
    fn clear(&mut self) {
        self.name.clear();
        self.value = 0.;
        self.training_step = 0;
        self.wall_time_secs = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Session {
    // message fields
    pub name: ::std::string::String,
    pub start_time_secs: f64,
    pub end_time_secs: f64,
    pub status: Status,
    pub model_uri: ::std::string::String,
    pub metric_values: ::protobuf::RepeatedField<MetricValue>,
    pub monitor_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Session {
    fn default() -> &'a Session {
        <Session as ::protobuf::Message>::default_instance()
    }
}

impl Session {
    pub fn new() -> Session {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // double start_time_secs = 2;


    pub fn get_start_time_secs(&self) -> f64 {
        self.start_time_secs
    }
    pub fn clear_start_time_secs(&mut self) {
        self.start_time_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_start_time_secs(&mut self, v: f64) {
        self.start_time_secs = v;
    }

    // double end_time_secs = 3;


    pub fn get_end_time_secs(&self) -> f64 {
        self.end_time_secs
    }
    pub fn clear_end_time_secs(&mut self) {
        self.end_time_secs = 0.;
    }

    // Param is passed by value, moved
    pub fn set_end_time_secs(&mut self, v: f64) {
        self.end_time_secs = v;
    }

    // .tensorboardrs.hparam.Status status = 4;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::STATUS_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }

    // string model_uri = 5;


    pub fn get_model_uri(&self) -> &str {
        &self.model_uri
    }
    pub fn clear_model_uri(&mut self) {
        self.model_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_uri(&mut self, v: ::std::string::String) {
        self.model_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_uri(&mut self) -> &mut ::std::string::String {
        &mut self.model_uri
    }

    // Take field
    pub fn take_model_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_uri, ::std::string::String::new())
    }

    // repeated .tensorboardrs.hparam.MetricValue metric_values = 6;


    pub fn get_metric_values(&self) -> &[MetricValue] {
        &self.metric_values
    }
    pub fn clear_metric_values(&mut self) {
        self.metric_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_values(&mut self, v: ::protobuf::RepeatedField<MetricValue>) {
        self.metric_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_values(&mut self) -> &mut ::protobuf::RepeatedField<MetricValue> {
        &mut self.metric_values
    }

    // Take field
    pub fn take_metric_values(&mut self) -> ::protobuf::RepeatedField<MetricValue> {
        ::std::mem::replace(&mut self.metric_values, ::protobuf::RepeatedField::new())
    }

    // string monitor_url = 7;


    pub fn get_monitor_url(&self) -> &str {
        &self.monitor_url
    }
    pub fn clear_monitor_url(&mut self) {
        self.monitor_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitor_url(&mut self, v: ::std::string::String) {
        self.monitor_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monitor_url(&mut self) -> &mut ::std::string::String {
        &mut self.monitor_url
    }

    // Take field
    pub fn take_monitor_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.monitor_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Session {
    fn is_initialized(&self) -> bool {
        for v in &self.metric_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.start_time_secs = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.end_time_secs = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_uri)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_values)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.monitor_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.start_time_secs != 0. {
            my_size += 9;
        }
        if self.end_time_secs != 0. {
            my_size += 9;
        }
        if self.status != Status::STATUS_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if !self.model_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.model_uri);
        }
        for value in &self.metric_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.monitor_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.monitor_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.start_time_secs != 0. {
            os.write_double(2, self.start_time_secs)?;
        }
        if self.end_time_secs != 0. {
            os.write_double(3, self.end_time_secs)?;
        }
        if self.status != Status::STATUS_UNKNOWN {
            os.write_enum(4, self.status.value())?;
        }
        if !self.model_uri.is_empty() {
            os.write_string(5, &self.model_uri)?;
        }
        for v in &self.metric_values {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.monitor_url.is_empty() {
            os.write_string(7, &self.monitor_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Session {
        Session::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Session| { &m.name },
                    |m: &mut Session| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "start_time_secs",
                    |m: &Session| { &m.start_time_secs },
                    |m: &mut Session| { &mut m.start_time_secs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "end_time_secs",
                    |m: &Session| { &m.end_time_secs },
                    |m: &mut Session| { &mut m.end_time_secs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &Session| { &m.status },
                    |m: &mut Session| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "model_uri",
                    |m: &Session| { &m.model_uri },
                    |m: &mut Session| { &mut m.model_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricValue>>(
                    "metric_values",
                    |m: &Session| { &m.metric_values },
                    |m: &mut Session| { &mut m.metric_values },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "monitor_url",
                    |m: &Session| { &m.monitor_url },
                    |m: &mut Session| { &mut m.monitor_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Session>(
                    "Session",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Session {
        static mut instance: ::protobuf::lazy::Lazy<Session> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Session::new)
        }
    }
}

impl ::protobuf::Clear for Session {
    fn clear(&mut self) {
        self.name.clear();
        self.start_time_secs = 0.;
        self.end_time_secs = 0.;
        self.status = Status::STATUS_UNKNOWN;
        self.model_uri.clear();
        self.metric_values.clear();
        self.monitor_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Session {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Session {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetExperimentRequest {
    // message fields
    pub experiment_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetExperimentRequest {
    fn default() -> &'a GetExperimentRequest {
        <GetExperimentRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetExperimentRequest {
    pub fn new() -> GetExperimentRequest {
        ::std::default::Default::default()
    }

    // string experiment_name = 1;


    pub fn get_experiment_name(&self) -> &str {
        &self.experiment_name
    }
    pub fn clear_experiment_name(&mut self) {
        self.experiment_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_experiment_name(&mut self, v: ::std::string::String) {
        self.experiment_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experiment_name(&mut self) -> &mut ::std::string::String {
        &mut self.experiment_name
    }

    // Take field
    pub fn take_experiment_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.experiment_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetExperimentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.experiment_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.experiment_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.experiment_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.experiment_name.is_empty() {
            os.write_string(1, &self.experiment_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetExperimentRequest {
        GetExperimentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "experiment_name",
                    |m: &GetExperimentRequest| { &m.experiment_name },
                    |m: &mut GetExperimentRequest| { &mut m.experiment_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetExperimentRequest>(
                    "GetExperimentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetExperimentRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetExperimentRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetExperimentRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetExperimentRequest {
    fn clear(&mut self) {
        self.experiment_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetExperimentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetExperimentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSessionGroupsRequest {
    // message fields
    pub experiment_name: ::std::string::String,
    pub allowed_statuses: ::std::vec::Vec<Status>,
    pub col_params: ::protobuf::RepeatedField<ColParams>,
    pub aggregation_type: AggregationType,
    pub aggregation_metric: ::protobuf::SingularPtrField<MetricName>,
    pub start_index: i32,
    pub slice_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSessionGroupsRequest {
    fn default() -> &'a ListSessionGroupsRequest {
        <ListSessionGroupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionGroupsRequest {
    pub fn new() -> ListSessionGroupsRequest {
        ::std::default::Default::default()
    }

    // string experiment_name = 6;


    pub fn get_experiment_name(&self) -> &str {
        &self.experiment_name
    }
    pub fn clear_experiment_name(&mut self) {
        self.experiment_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_experiment_name(&mut self, v: ::std::string::String) {
        self.experiment_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experiment_name(&mut self) -> &mut ::std::string::String {
        &mut self.experiment_name
    }

    // Take field
    pub fn take_experiment_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.experiment_name, ::std::string::String::new())
    }

    // repeated .tensorboardrs.hparam.Status allowed_statuses = 7;


    pub fn get_allowed_statuses(&self) -> &[Status] {
        &self.allowed_statuses
    }
    pub fn clear_allowed_statuses(&mut self) {
        self.allowed_statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_statuses(&mut self, v: ::std::vec::Vec<Status>) {
        self.allowed_statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_statuses(&mut self) -> &mut ::std::vec::Vec<Status> {
        &mut self.allowed_statuses
    }

    // Take field
    pub fn take_allowed_statuses(&mut self) -> ::std::vec::Vec<Status> {
        ::std::mem::replace(&mut self.allowed_statuses, ::std::vec::Vec::new())
    }

    // repeated .tensorboardrs.hparam.ColParams col_params = 1;


    pub fn get_col_params(&self) -> &[ColParams] {
        &self.col_params
    }
    pub fn clear_col_params(&mut self) {
        self.col_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_col_params(&mut self, v: ::protobuf::RepeatedField<ColParams>) {
        self.col_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_col_params(&mut self) -> &mut ::protobuf::RepeatedField<ColParams> {
        &mut self.col_params
    }

    // Take field
    pub fn take_col_params(&mut self) -> ::protobuf::RepeatedField<ColParams> {
        ::std::mem::replace(&mut self.col_params, ::protobuf::RepeatedField::new())
    }

    // .tensorboardrs.hparam.AggregationType aggregation_type = 2;


    pub fn get_aggregation_type(&self) -> AggregationType {
        self.aggregation_type
    }
    pub fn clear_aggregation_type(&mut self) {
        self.aggregation_type = AggregationType::AGGREGATION_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_aggregation_type(&mut self, v: AggregationType) {
        self.aggregation_type = v;
    }

    // .tensorboardrs.hparam.MetricName aggregation_metric = 3;


    pub fn get_aggregation_metric(&self) -> &MetricName {
        self.aggregation_metric.as_ref().unwrap_or_else(|| MetricName::default_instance())
    }
    pub fn clear_aggregation_metric(&mut self) {
        self.aggregation_metric.clear();
    }

    pub fn has_aggregation_metric(&self) -> bool {
        self.aggregation_metric.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregation_metric(&mut self, v: MetricName) {
        self.aggregation_metric = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregation_metric(&mut self) -> &mut MetricName {
        if self.aggregation_metric.is_none() {
            self.aggregation_metric.set_default();
        }
        self.aggregation_metric.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregation_metric(&mut self) -> MetricName {
        self.aggregation_metric.take().unwrap_or_else(|| MetricName::new())
    }

    // int32 start_index = 4;


    pub fn get_start_index(&self) -> i32 {
        self.start_index
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: i32) {
        self.start_index = v;
    }

    // int32 slice_size = 5;


    pub fn get_slice_size(&self) -> i32 {
        self.slice_size
    }
    pub fn clear_slice_size(&mut self) {
        self.slice_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_slice_size(&mut self, v: i32) {
        self.slice_size = v;
    }
}

impl ::protobuf::Message for ListSessionGroupsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.col_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregation_metric {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.experiment_name)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.allowed_statuses, 7, &mut self.unknown_fields)?
                },
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.col_params)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aggregation_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregation_metric)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start_index = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slice_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.experiment_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.experiment_name);
        }
        for value in &self.allowed_statuses {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in &self.col_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.aggregation_type != AggregationType::AGGREGATION_UNSET {
            my_size += ::protobuf::rt::enum_size(2, self.aggregation_type);
        }
        if let Some(ref v) = self.aggregation_metric.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.slice_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.slice_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.experiment_name.is_empty() {
            os.write_string(6, &self.experiment_name)?;
        }
        for v in &self.allowed_statuses {
            os.write_enum(7, v.value())?;
        };
        for v in &self.col_params {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.aggregation_type != AggregationType::AGGREGATION_UNSET {
            os.write_enum(2, self.aggregation_type.value())?;
        }
        if let Some(ref v) = self.aggregation_metric.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_index != 0 {
            os.write_int32(4, self.start_index)?;
        }
        if self.slice_size != 0 {
            os.write_int32(5, self.slice_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSessionGroupsRequest {
        ListSessionGroupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "experiment_name",
                    |m: &ListSessionGroupsRequest| { &m.experiment_name },
                    |m: &mut ListSessionGroupsRequest| { &mut m.experiment_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "allowed_statuses",
                    |m: &ListSessionGroupsRequest| { &m.allowed_statuses },
                    |m: &mut ListSessionGroupsRequest| { &mut m.allowed_statuses },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColParams>>(
                    "col_params",
                    |m: &ListSessionGroupsRequest| { &m.col_params },
                    |m: &mut ListSessionGroupsRequest| { &mut m.col_params },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AggregationType>>(
                    "aggregation_type",
                    |m: &ListSessionGroupsRequest| { &m.aggregation_type },
                    |m: &mut ListSessionGroupsRequest| { &mut m.aggregation_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                    "aggregation_metric",
                    |m: &ListSessionGroupsRequest| { &m.aggregation_metric },
                    |m: &mut ListSessionGroupsRequest| { &mut m.aggregation_metric },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "start_index",
                    |m: &ListSessionGroupsRequest| { &m.start_index },
                    |m: &mut ListSessionGroupsRequest| { &mut m.start_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "slice_size",
                    |m: &ListSessionGroupsRequest| { &m.slice_size },
                    |m: &mut ListSessionGroupsRequest| { &mut m.slice_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSessionGroupsRequest>(
                    "ListSessionGroupsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSessionGroupsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListSessionGroupsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListSessionGroupsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListSessionGroupsRequest {
    fn clear(&mut self) {
        self.experiment_name.clear();
        self.allowed_statuses.clear();
        self.col_params.clear();
        self.aggregation_type = AggregationType::AGGREGATION_UNSET;
        self.aggregation_metric.clear();
        self.start_index = 0;
        self.slice_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSessionGroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionGroupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColParams {
    // message fields
    pub order: SortOrder,
    pub missing_values_first: bool,
    pub exclude_missing_values: bool,
    // message oneof groups
    pub name: ::std::option::Option<ColParams_oneof_name>,
    pub filter: ::std::option::Option<ColParams_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColParams {
    fn default() -> &'a ColParams {
        <ColParams as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColParams_oneof_name {
    metric(MetricName),
    hparam(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColParams_oneof_filter {
    filter_regexp(::std::string::String),
    filter_interval(Interval),
    filter_discrete(::protobuf::well_known_types::ListValue),
}

impl ColParams {
    pub fn new() -> ColParams {
        ::std::default::Default::default()
    }

    // .tensorboardrs.hparam.MetricName metric = 1;


    pub fn get_metric(&self) -> &MetricName {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::metric(ref v)) => v,
            _ => MetricName::default_instance(),
        }
    }
    pub fn clear_metric(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_metric(&self) -> bool {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::metric(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metric(&mut self, v: MetricName) {
        self.name = ::std::option::Option::Some(ColParams_oneof_name::metric(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metric(&mut self) -> &mut MetricName {
        if let ::std::option::Option::Some(ColParams_oneof_name::metric(_)) = self.name {
        } else {
            self.name = ::std::option::Option::Some(ColParams_oneof_name::metric(MetricName::new()));
        }
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::metric(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metric(&mut self) -> MetricName {
        if self.has_metric() {
            match self.name.take() {
                ::std::option::Option::Some(ColParams_oneof_name::metric(v)) => v,
                _ => panic!(),
            }
        } else {
            MetricName::new()
        }
    }

    // string hparam = 2;


    pub fn get_hparam(&self) -> &str {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::hparam(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_hparam(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_hparam(&self) -> bool {
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::hparam(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hparam(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(ColParams_oneof_name::hparam(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hparam(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ColParams_oneof_name::hparam(_)) = self.name {
        } else {
            self.name = ::std::option::Option::Some(ColParams_oneof_name::hparam(::std::string::String::new()));
        }
        match self.name {
            ::std::option::Option::Some(ColParams_oneof_name::hparam(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hparam(&mut self) -> ::std::string::String {
        if self.has_hparam() {
            match self.name.take() {
                ::std::option::Option::Some(ColParams_oneof_name::hparam(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .tensorboardrs.hparam.SortOrder order = 3;


    pub fn get_order(&self) -> SortOrder {
        self.order
    }
    pub fn clear_order(&mut self) {
        self.order = SortOrder::ORDER_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: SortOrder) {
        self.order = v;
    }

    // bool missing_values_first = 4;


    pub fn get_missing_values_first(&self) -> bool {
        self.missing_values_first
    }
    pub fn clear_missing_values_first(&mut self) {
        self.missing_values_first = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_values_first(&mut self, v: bool) {
        self.missing_values_first = v;
    }

    // string filter_regexp = 5;


    pub fn get_filter_regexp(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_filter_regexp(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter_regexp(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_regexp(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_regexp(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_regexp(&mut self) -> ::std::string::String {
        if self.has_filter_regexp() {
            match self.filter.take() {
                ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .tensorboardrs.hparam.Interval filter_interval = 6;


    pub fn get_filter_interval(&self) -> &Interval {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(ref v)) => v,
            _ => Interval::default_instance(),
        }
    }
    pub fn clear_filter_interval(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter_interval(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_interval(&mut self, v: Interval) {
        self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_interval(&mut self) -> &mut Interval {
        if let ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(Interval::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_interval(&mut self) -> Interval {
        if self.has_filter_interval() {
            match self.filter.take() {
                ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(v)) => v,
                _ => panic!(),
            }
        } else {
            Interval::new()
        }
    }

    // .google.protobuf.ListValue filter_discrete = 7;


    pub fn get_filter_discrete(&self) -> &::protobuf::well_known_types::ListValue {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(ref v)) => v,
            _ => ::protobuf::well_known_types::ListValue::default_instance(),
        }
    }
    pub fn clear_filter_discrete(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter_discrete(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_discrete(&mut self, v: ::protobuf::well_known_types::ListValue) {
        self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_discrete(&mut self) -> &mut ::protobuf::well_known_types::ListValue {
        if let ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(::protobuf::well_known_types::ListValue::new()));
        }
        match self.filter {
            ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_discrete(&mut self) -> ::protobuf::well_known_types::ListValue {
        if self.has_filter_discrete() {
            match self.filter.take() {
                ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::ListValue::new()
        }
    }

    // bool exclude_missing_values = 8;


    pub fn get_exclude_missing_values(&self) -> bool {
        self.exclude_missing_values
    }
    pub fn clear_exclude_missing_values(&mut self) {
        self.exclude_missing_values = false;
    }

    // Param is passed by value, moved
    pub fn set_exclude_missing_values(&mut self, v: bool) {
        self.exclude_missing_values = v;
    }
}

impl ::protobuf::Message for ColParams {
    fn is_initialized(&self) -> bool {
        if let Some(ColParams_oneof_name::metric(ref v)) = self.name {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ColParams_oneof_filter::filter_interval(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ColParams_oneof_filter::filter_discrete(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(ColParams_oneof_name::metric(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(ColParams_oneof_name::hparam(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_values_first = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_regexp(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_interval(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(ColParams_oneof_filter::filter_discrete(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exclude_missing_values = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.order != SortOrder::ORDER_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.order);
        }
        if self.missing_values_first != false {
            my_size += 2;
        }
        if self.exclude_missing_values != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.name {
            match v {
                &ColParams_oneof_name::metric(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ColParams_oneof_name::hparam(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ColParams_oneof_filter::filter_regexp(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &ColParams_oneof_filter::filter_interval(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ColParams_oneof_filter::filter_discrete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.order != SortOrder::ORDER_UNSPECIFIED {
            os.write_enum(3, self.order.value())?;
        }
        if self.missing_values_first != false {
            os.write_bool(4, self.missing_values_first)?;
        }
        if self.exclude_missing_values != false {
            os.write_bool(8, self.exclude_missing_values)?;
        }
        if let ::std::option::Option::Some(ref v) = self.name {
            match v {
                &ColParams_oneof_name::metric(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ColParams_oneof_name::hparam(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &ColParams_oneof_filter::filter_regexp(ref v) => {
                    os.write_string(5, v)?;
                },
                &ColParams_oneof_filter::filter_interval(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ColParams_oneof_filter::filter_discrete(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColParams {
        ColParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MetricName>(
                    "metric",
                    ColParams::has_metric,
                    ColParams::get_metric,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "hparam",
                    ColParams::has_hparam,
                    ColParams::get_hparam,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortOrder>>(
                    "order",
                    |m: &ColParams| { &m.order },
                    |m: &mut ColParams| { &mut m.order },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "missing_values_first",
                    |m: &ColParams| { &m.missing_values_first },
                    |m: &mut ColParams| { &mut m.missing_values_first },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "filter_regexp",
                    ColParams::has_filter_regexp,
                    ColParams::get_filter_regexp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Interval>(
                    "filter_interval",
                    ColParams::has_filter_interval,
                    ColParams::get_filter_interval,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::ListValue>(
                    "filter_discrete",
                    ColParams::has_filter_discrete,
                    ColParams::get_filter_discrete,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "exclude_missing_values",
                    |m: &ColParams| { &m.exclude_missing_values },
                    |m: &mut ColParams| { &mut m.exclude_missing_values },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColParams>(
                    "ColParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ColParams {
        static mut instance: ::protobuf::lazy::Lazy<ColParams> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ColParams::new)
        }
    }
}

impl ::protobuf::Clear for ColParams {
    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.order = SortOrder::ORDER_UNSPECIFIED;
        self.missing_values_first = false;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.exclude_missing_values = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSessionGroupsResponse {
    // message fields
    pub session_groups: ::protobuf::RepeatedField<SessionGroup>,
    pub total_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSessionGroupsResponse {
    fn default() -> &'a ListSessionGroupsResponse {
        <ListSessionGroupsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSessionGroupsResponse {
    pub fn new() -> ListSessionGroupsResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorboardrs.hparam.SessionGroup session_groups = 1;


    pub fn get_session_groups(&self) -> &[SessionGroup] {
        &self.session_groups
    }
    pub fn clear_session_groups(&mut self) {
        self.session_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_groups(&mut self, v: ::protobuf::RepeatedField<SessionGroup>) {
        self.session_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_groups(&mut self) -> &mut ::protobuf::RepeatedField<SessionGroup> {
        &mut self.session_groups
    }

    // Take field
    pub fn take_session_groups(&mut self) -> ::protobuf::RepeatedField<SessionGroup> {
        ::std::mem::replace(&mut self.session_groups, ::protobuf::RepeatedField::new())
    }

    // int32 total_size = 3;


    pub fn get_total_size(&self) -> i32 {
        self.total_size
    }
    pub fn clear_total_size(&mut self) {
        self.total_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_size(&mut self, v: i32) {
        self.total_size = v;
    }
}

impl ::protobuf::Message for ListSessionGroupsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.session_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.session_groups)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.session_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.total_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.session_groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.total_size != 0 {
            os.write_int32(3, self.total_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSessionGroupsResponse {
        ListSessionGroupsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionGroup>>(
                    "session_groups",
                    |m: &ListSessionGroupsResponse| { &m.session_groups },
                    |m: &mut ListSessionGroupsResponse| { &mut m.session_groups },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "total_size",
                    |m: &ListSessionGroupsResponse| { &m.total_size },
                    |m: &mut ListSessionGroupsResponse| { &mut m.total_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListSessionGroupsResponse>(
                    "ListSessionGroupsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSessionGroupsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListSessionGroupsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListSessionGroupsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListSessionGroupsResponse {
    fn clear(&mut self) {
        self.session_groups.clear();
        self.total_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSessionGroupsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSessionGroupsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMetricEvalsRequest {
    // message fields
    pub experiment_name: ::std::string::String,
    pub session_name: ::std::string::String,
    pub metric_name: ::protobuf::SingularPtrField<MetricName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMetricEvalsRequest {
    fn default() -> &'a ListMetricEvalsRequest {
        <ListMetricEvalsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListMetricEvalsRequest {
    pub fn new() -> ListMetricEvalsRequest {
        ::std::default::Default::default()
    }

    // string experiment_name = 3;


    pub fn get_experiment_name(&self) -> &str {
        &self.experiment_name
    }
    pub fn clear_experiment_name(&mut self) {
        self.experiment_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_experiment_name(&mut self, v: ::std::string::String) {
        self.experiment_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experiment_name(&mut self) -> &mut ::std::string::String {
        &mut self.experiment_name
    }

    // Take field
    pub fn take_experiment_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.experiment_name, ::std::string::String::new())
    }

    // string session_name = 1;


    pub fn get_session_name(&self) -> &str {
        &self.session_name
    }
    pub fn clear_session_name(&mut self) {
        self.session_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_name(&mut self, v: ::std::string::String) {
        self.session_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_name(&mut self) -> &mut ::std::string::String {
        &mut self.session_name
    }

    // Take field
    pub fn take_session_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_name, ::std::string::String::new())
    }

    // .tensorboardrs.hparam.MetricName metric_name = 2;


    pub fn get_metric_name(&self) -> &MetricName {
        self.metric_name.as_ref().unwrap_or_else(|| MetricName::default_instance())
    }
    pub fn clear_metric_name(&mut self) {
        self.metric_name.clear();
    }

    pub fn has_metric_name(&self) -> bool {
        self.metric_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metric_name(&mut self, v: MetricName) {
        self.metric_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metric_name(&mut self) -> &mut MetricName {
        if self.metric_name.is_none() {
            self.metric_name.set_default();
        }
        self.metric_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_metric_name(&mut self) -> MetricName {
        self.metric_name.take().unwrap_or_else(|| MetricName::new())
    }
}

impl ::protobuf::Message for ListMetricEvalsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.metric_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.experiment_name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metric_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.experiment_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.experiment_name);
        }
        if !self.session_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_name);
        }
        if let Some(ref v) = self.metric_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.experiment_name.is_empty() {
            os.write_string(3, &self.experiment_name)?;
        }
        if !self.session_name.is_empty() {
            os.write_string(1, &self.session_name)?;
        }
        if let Some(ref v) = self.metric_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMetricEvalsRequest {
        ListMetricEvalsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "experiment_name",
                    |m: &ListMetricEvalsRequest| { &m.experiment_name },
                    |m: &mut ListMetricEvalsRequest| { &mut m.experiment_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "session_name",
                    |m: &ListMetricEvalsRequest| { &m.session_name },
                    |m: &mut ListMetricEvalsRequest| { &mut m.session_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricName>>(
                    "metric_name",
                    |m: &ListMetricEvalsRequest| { &m.metric_name },
                    |m: &mut ListMetricEvalsRequest| { &mut m.metric_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMetricEvalsRequest>(
                    "ListMetricEvalsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListMetricEvalsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListMetricEvalsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListMetricEvalsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListMetricEvalsRequest {
    fn clear(&mut self) {
        self.experiment_name.clear();
        self.session_name.clear();
        self.metric_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMetricEvalsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMetricEvalsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataType {
    DATA_TYPE_UNSET = 0,
    DATA_TYPE_STRING = 1,
    DATA_TYPE_BOOL = 2,
    DATA_TYPE_FLOAT64 = 3,
}

impl ::protobuf::ProtobufEnum for DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::DATA_TYPE_UNSET),
            1 => ::std::option::Option::Some(DataType::DATA_TYPE_STRING),
            2 => ::std::option::Option::Some(DataType::DATA_TYPE_BOOL),
            3 => ::std::option::Option::Some(DataType::DATA_TYPE_FLOAT64),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataType] = &[
            DataType::DATA_TYPE_UNSET,
            DataType::DATA_TYPE_STRING,
            DataType::DATA_TYPE_BOOL,
            DataType::DATA_TYPE_FLOAT64,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataType>("DataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataType {
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::DATA_TYPE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatasetType {
    DATASET_UNKNOWN = 0,
    DATASET_TRAINING = 1,
    DATASET_VALIDATION = 2,
}

impl ::protobuf::ProtobufEnum for DatasetType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatasetType> {
        match value {
            0 => ::std::option::Option::Some(DatasetType::DATASET_UNKNOWN),
            1 => ::std::option::Option::Some(DatasetType::DATASET_TRAINING),
            2 => ::std::option::Option::Some(DatasetType::DATASET_VALIDATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatasetType] = &[
            DatasetType::DATASET_UNKNOWN,
            DatasetType::DATASET_TRAINING,
            DatasetType::DATASET_VALIDATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatasetType>("DatasetType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatasetType {
}

impl ::std::default::Default for DatasetType {
    fn default() -> Self {
        DatasetType::DATASET_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for DatasetType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    STATUS_UNKNOWN = 0,
    STATUS_SUCCESS = 1,
    STATUS_FAILURE = 2,
    STATUS_RUNNING = 3,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            0 => ::std::option::Option::Some(Status::STATUS_UNKNOWN),
            1 => ::std::option::Option::Some(Status::STATUS_SUCCESS),
            2 => ::std::option::Option::Some(Status::STATUS_FAILURE),
            3 => ::std::option::Option::Some(Status::STATUS_RUNNING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::STATUS_UNKNOWN,
            Status::STATUS_SUCCESS,
            Status::STATUS_FAILURE,
            Status::STATUS_RUNNING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<Status>("Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Status {
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::STATUS_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SortOrder {
    ORDER_UNSPECIFIED = 0,
    ORDER_ASC = 1,
    ORDER_DESC = 2,
}

impl ::protobuf::ProtobufEnum for SortOrder {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SortOrder> {
        match value {
            0 => ::std::option::Option::Some(SortOrder::ORDER_UNSPECIFIED),
            1 => ::std::option::Option::Some(SortOrder::ORDER_ASC),
            2 => ::std::option::Option::Some(SortOrder::ORDER_DESC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SortOrder] = &[
            SortOrder::ORDER_UNSPECIFIED,
            SortOrder::ORDER_ASC,
            SortOrder::ORDER_DESC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<SortOrder>("SortOrder", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SortOrder {
}

impl ::std::default::Default for SortOrder {
    fn default() -> Self {
        SortOrder::ORDER_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for SortOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AggregationType {
    AGGREGATION_UNSET = 0,
    AGGREGATION_AVG = 1,
    AGGREGATION_MEDIAN = 2,
    AGGREGATION_MIN = 3,
    AGGREGATION_MAX = 4,
}

impl ::protobuf::ProtobufEnum for AggregationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AggregationType> {
        match value {
            0 => ::std::option::Option::Some(AggregationType::AGGREGATION_UNSET),
            1 => ::std::option::Option::Some(AggregationType::AGGREGATION_AVG),
            2 => ::std::option::Option::Some(AggregationType::AGGREGATION_MEDIAN),
            3 => ::std::option::Option::Some(AggregationType::AGGREGATION_MIN),
            4 => ::std::option::Option::Some(AggregationType::AGGREGATION_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AggregationType] = &[
            AggregationType::AGGREGATION_UNSET,
            AggregationType::AGGREGATION_AVG,
            AggregationType::AGGREGATION_MEDIAN,
            AggregationType::AGGREGATION_MIN,
            AggregationType::AGGREGATION_MAX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<AggregationType>("AggregationType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AggregationType {
}

impl ::std::default::Default for AggregationType {
    fn default() -> Self {
        AggregationType::AGGREGATION_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!src/tensorboardrs/proto/api.proto\x12\x14tensorboardrs.hparam\x1a\x1c\
    google/protobuf/struct.proto\"\x8c\x02\n\nExperiment\x12\x12\n\x04name\
    \x18\x06\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x01\x20\x01(\t\
    R\x0bdescription\x12\x12\n\x04user\x18\x02\x20\x01(\tR\x04user\x12*\n\
    \x11time_created_secs\x18\x03\x20\x01(\x01R\x0ftimeCreatedSecs\x12C\n\
    \x0chparam_infos\x18\x04\x20\x03(\x0b2\x20.tensorboardrs.hparam.HParamIn\
    foR\x0bhparamInfos\x12C\n\x0cmetric_infos\x18\x05\x20\x03(\x0b2\x20.tens\
    orboardrs.hparam.MetricInfoR\x0bmetricInfos\"\xb5\x02\n\nHParamInfo\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cdisplay_name\x18\
    \x02\x20\x01(\tR\x0bdisplayName\x12\x20\n\x0bdescription\x18\x03\x20\x01\
    (\tR\x0bdescription\x122\n\x04type\x18\x04\x20\x01(\x0e2\x1e.tensorboard\
    rs.hparam.DataTypeR\x04type\x12E\n\x0fdomain_discrete\x18\x05\x20\x01(\
    \x0b2\x1a.google.protobuf.ListValueH\0R\x0edomainDiscrete\x12I\n\x0fdoma\
    in_interval\x18\x06\x20\x01(\x0b2\x1e.tensorboardrs.hparam.IntervalH\0R\
    \x0edomainIntervalB\x08\n\x06domain\"D\n\x08Interval\x12\x1b\n\tmin_valu\
    e\x18\x01\x20\x01(\x01R\x08minValue\x12\x1b\n\tmax_value\x18\x02\x20\x01\
    (\x01R\x08maxValue\"4\n\nMetricName\x12\x14\n\x05group\x18\x01\x20\x01(\
    \tR\x05group\x12\x10\n\x03tag\x18\x02\x20\x01(\tR\x03tag\"\xcd\x01\n\nMe\
    tricInfo\x124\n\x04name\x18\x01\x20\x01(\x0b2\x20.tensorboardrs.hparam.M\
    etricNameR\x04name\x12!\n\x0cdisplay_name\x18\x03\x20\x01(\tR\x0bdisplay\
    Name\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0bdescription\x12D\n\
    \x0cdataset_type\x18\x05\x20\x01(\x0e2!.tensorboardrs.hparam.DatasetType\
    R\x0bdatasetType\"\xe5\x02\n\x0cSessionGroup\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12I\n\x07hparams\x18\x02\x20\x03(\x0b2/.tensorboar\
    drs.hparam.SessionGroup.HparamsEntryR\x07hparams\x12F\n\rmetric_values\
    \x18\x03\x20\x03(\x0b2!.tensorboardrs.hparam.MetricValueR\x0cmetricValue\
    s\x129\n\x08sessions\x18\x04\x20\x03(\x0b2\x1d.tensorboardrs.hparam.Sess\
    ionR\x08sessions\x12\x1f\n\x0bmonitor_url\x18\x05\x20\x01(\tR\nmonitorUr\
    l\x1aR\n\x0cHparamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    ,\n\x05value\x18\x02\x20\x01(\x0b2\x16.google.protobuf.ValueR\x05value:\
    \x028\x01\"\xa4\x01\n\x0bMetricValue\x124\n\x04name\x18\x01\x20\x01(\x0b\
    2\x20.tensorboardrs.hparam.MetricNameR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x01R\x05value\x12#\n\rtraining_step\x18\x03\x20\x01(\x05R\
    \x0ctrainingStep\x12$\n\x0ewall_time_secs\x18\x04\x20\x01(\x01R\x0cwallT\
    imeSecs\"\xa5\x02\n\x07Session\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12&\n\x0fstart_time_secs\x18\x02\x20\x01(\x01R\rstartTimeSecs\x12\
    \"\n\rend_time_secs\x18\x03\x20\x01(\x01R\x0bendTimeSecs\x124\n\x06statu\
    s\x18\x04\x20\x01(\x0e2\x1c.tensorboardrs.hparam.StatusR\x06status\x12\
    \x1b\n\tmodel_uri\x18\x05\x20\x01(\tR\x08modelUri\x12F\n\rmetric_values\
    \x18\x06\x20\x03(\x0b2!.tensorboardrs.hparam.MetricValueR\x0cmetricValue\
    s\x12\x1f\n\x0bmonitor_url\x18\x07\x20\x01(\tR\nmonitorUrl\"?\n\x14GetEx\
    perimentRequest\x12'\n\x0fexperiment_name\x18\x01\x20\x01(\tR\x0eexperim\
    entName\"\xaf\x03\n\x18ListSessionGroupsRequest\x12'\n\x0fexperiment_nam\
    e\x18\x06\x20\x01(\tR\x0eexperimentName\x12G\n\x10allowed_statuses\x18\
    \x07\x20\x03(\x0e2\x1c.tensorboardrs.hparam.StatusR\x0fallowedStatuses\
    \x12>\n\ncol_params\x18\x01\x20\x03(\x0b2\x1f.tensorboardrs.hparam.ColPa\
    ramsR\tcolParams\x12P\n\x10aggregation_type\x18\x02\x20\x01(\x0e2%.tenso\
    rboardrs.hparam.AggregationTypeR\x0faggregationType\x12O\n\x12aggregatio\
    n_metric\x18\x03\x20\x01(\x0b2\x20.tensorboardrs.hparam.MetricNameR\x11a\
    ggregationMetric\x12\x1f\n\x0bstart_index\x18\x04\x20\x01(\x05R\nstartIn\
    dex\x12\x1d\n\nslice_size\x18\x05\x20\x01(\x05R\tsliceSize\"\xcb\x03\n\t\
    ColParams\x12:\n\x06metric\x18\x01\x20\x01(\x0b2\x20.tensorboardrs.hpara\
    m.MetricNameH\0R\x06metric\x12\x18\n\x06hparam\x18\x02\x20\x01(\tH\0R\
    \x06hparam\x125\n\x05order\x18\x03\x20\x01(\x0e2\x1f.tensorboardrs.hpara\
    m.SortOrderR\x05order\x120\n\x14missing_values_first\x18\x04\x20\x01(\
    \x08R\x12missingValuesFirst\x12%\n\rfilter_regexp\x18\x05\x20\x01(\tH\
    \x01R\x0cfilterRegexp\x12I\n\x0ffilter_interval\x18\x06\x20\x01(\x0b2\
    \x1e.tensorboardrs.hparam.IntervalH\x01R\x0efilterInterval\x12E\n\x0ffil\
    ter_discrete\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.ListValueH\x01R\
    \x0efilterDiscrete\x124\n\x16exclude_missing_values\x18\x08\x20\x01(\x08\
    R\x14excludeMissingValuesB\x06\n\x04nameB\x08\n\x06filter\"\x85\x01\n\
    \x19ListSessionGroupsResponse\x12I\n\x0esession_groups\x18\x01\x20\x03(\
    \x0b2\".tensorboardrs.hparam.SessionGroupR\rsessionGroups\x12\x1d\n\ntot\
    al_size\x18\x03\x20\x01(\x05R\ttotalSize\"\xa7\x01\n\x16ListMetricEvalsR\
    equest\x12'\n\x0fexperiment_name\x18\x03\x20\x01(\tR\x0eexperimentName\
    \x12!\n\x0csession_name\x18\x01\x20\x01(\tR\x0bsessionName\x12A\n\x0bmet\
    ric_name\x18\x02\x20\x01(\x0b2\x20.tensorboardrs.hparam.MetricNameR\nmet\
    ricName*`\n\x08DataType\x12\x13\n\x0fDATA_TYPE_UNSET\x10\0\x12\x14\n\x10\
    DATA_TYPE_STRING\x10\x01\x12\x12\n\x0eDATA_TYPE_BOOL\x10\x02\x12\x15\n\
    \x11DATA_TYPE_FLOAT64\x10\x03*P\n\x0bDatasetType\x12\x13\n\x0fDATASET_UN\
    KNOWN\x10\0\x12\x14\n\x10DATASET_TRAINING\x10\x01\x12\x16\n\x12DATASET_V\
    ALIDATION\x10\x02*X\n\x06Status\x12\x12\n\x0eSTATUS_UNKNOWN\x10\0\x12\
    \x12\n\x0eSTATUS_SUCCESS\x10\x01\x12\x12\n\x0eSTATUS_FAILURE\x10\x02\x12\
    \x12\n\x0eSTATUS_RUNNING\x10\x03*A\n\tSortOrder\x12\x15\n\x11ORDER_UNSPE\
    CIFIED\x10\0\x12\r\n\tORDER_ASC\x10\x01\x12\x0e\n\nORDER_DESC\x10\x02*\
    \x7f\n\x0fAggregationType\x12\x15\n\x11AGGREGATION_UNSET\x10\0\x12\x13\n\
    \x0fAGGREGATION_AVG\x10\x01\x12\x16\n\x12AGGREGATION_MEDIAN\x10\x02\x12\
    \x13\n\x0fAGGREGATION_MIN\x10\x03\x12\x13\n\x0fAGGREGATION_MAX\x10\x04J\
    \xc3\x84\x01\n\x07\x12\x05\x1e\0\x8f\x03\x01\n\x95\x0b\n\x01\x0c\x12\x03\
    \x1e\0\x122\x94\x05\x20Copyright\x202019\x20The\x20TensorFlow\x20Authors\
    .\x20All\x20Rights\x20Reserved.\n\nLicensed\x20under\x20the\x20Apache\
    \x20License,\x20Version\x202.0\x20(the\x20\"License\");\nyou\x20may\x20n\
    ot\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\
    \x20License.\nYou\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless\x20requir\
    ed\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\ndistributed\x20under\x20the\x20License\x20is\x20distribute\
    d\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\nWITHOUT\x20WARRANTIES\x20OR\x20\
    CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\
    \nSee\x20the\x20License\x20for\x20the\x20specific\x20language\x20governi\
    ng\x20permissions\x20and\nlimitations\x20under\x20the\x20License.\n=====\
    ========================================================================\
    =2\xfd\x02\x20Defines\x20a\x20proto3-based\x20REST\x20API\x20that\x20the\
    \x20HParams\x20web-component\x20of\x20the\x20plugin\n\x20would\x20use\
    \x20to\x20read\x20data\x20from\x20a\x20hyperparameter-tuning\x20experime\
    nt.\n\x20This\x20file\x20defines\x20the\x20message\x20types\x20(resource\
    s)\x20used\n\x20to\x20pass\x20information\x20into\x20and\x20out\x20of\
    \x20the\x20API\x20methods.\x20These\x20messages\x20will\x20be\n\x20trans\
    mitted\x20using\x20proto3\x20native\x20JSON\x20encoding.\x20See\x20http_\
    api.md\x20for\x20a\n\x20description\x20of\x20the\x20actual\x20HTTP\x20AP\
    I.\n2\x8d\x02\x20General\x20note:\x20in\x20what\x20follows\x20we\x20use\
    \x20the\x20field\x20'name'\x20of\x20a\x20message\x20to\n\x20stores\x20it\
    s\x20id.\x20We\x20avoid\x20calling\x20this\x20field\x20'id'\x20since\x20\
    it\x20is\x20a\x20reserved\x20word\n\x20in\x20Python,\x20as\x20well\x20as\
    \x20to\x20be\x20more\x20compliant\x20with\x20the\x20API\x20style\x20guid\
    e\n\x20detailed\x20in\x20https://cloud.google.com/apis/design/.\n2d\x20I\
    MPORTANT:\x20If\x20you\x20change\x20any\x20of\x20the\x20messages\x20here\
    ,\x20make\x20sure\x20to\x20also\x20update\n\x20api.d.ts\x20accordingly.\
    \n\n\t\n\x02\x03\0\x12\x03\x20\0&\n\x08\n\x01\x02\x12\x03\"\0\x1d\n\x8d\
    \x06\n\x02\x04\0\x12\x042\0E\x01\x1a\x80\x06\x20Represents\x20a\x20singl\
    e\x20experiment.\n\x20An\x20experiment\x20consists\x20of\x20multiple\x20\
    \"sessions\".\x20Typically,\x20in\x20each\x20session\n\x20a\x20model\x20\
    is\x20trained\x20for\x20a\x20given\x20set\x20of\x20hyperparameter\x20val\
    ues.\x20In\x20each\x20session\n\x20a\x20training\x20program\x20may\x20ge\
    nerate\x20one\x20or\x20more\x20series\x20of\x20real\x20numbers--each\n\
    \x20containing\x20the\x20evaluation\x20of\x20some\x20metric\x20on\x20the\
    \x20model\x20at\x20different\x20training\n\x20steps.\n\n\x20Note\x20that\
    \x20Sessions\x20can\x20consist\x20of\x20multiple\x20Tensorboard\x20\"run\
    s\",\x20since\x20in\n\x20a\x20distributed\x20Tensorflow\x20deployment,\
    \x20training\x20can\x20be\x20accomplished\x20using\n\x20several\x20coopo\
    rating\x20processes,\x20each\x20one\x20emitting\x20Summary\x20data\x20to\
    \x20a\x20different\n\x20log\x20directory\x20or\x20run.\x20For\x20example\
    ,\x20in\x20a\x20single\x20session\x20one\x20process\x20could\n\x20period\
    ically\x20compute\x20the\x20loss\x20on\x20the\x20validation\x20set,\x20a\
    nd\x20another\x20could\n\x20compute\x20the\x20loss\x20on\x20the\x20train\
    ing\x20set.\n\x20NEXT_TAG:\x207\n\n\n\n\x03\x04\0\x01\x12\x032\x08\x12\n\
    \x84\x01\n\x04\x04\0\x02\0\x12\x035\x02\x12\x1aw\x20--\x20Experiments\
    \x20are\x20scoped\x20by\x20a\x20global\x20name.\n\x20Currently,\x20Tenso\
    rboard\x20supports\x20displaying\x20data\x20for\x20a\x20single\x20experi\
    ment.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x035\x02\x08\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x035\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x035\x10\x11\n3\
    \n\x04\x04\0\x02\x01\x12\x038\x02\x19\x1a&\x20A\x20description.\x20May\
    \x20contain\x20markdown.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x038\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x038\t\x14\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x038\x17\x18\n2\n\x04\x04\0\x02\x02\x12\x03;\x02\x12\x1a%\
    \x20An\x20id\x20for\x20the\x20owning\x20user\x20or\x20group.\n\n\x0c\n\
    \x05\x04\0\x02\x02\x05\x12\x03;\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x03;\t\r\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03;\x10\x11\nT\n\x04\
    \x04\0\x02\x03\x12\x03>\x02\x1f\x1aG\x20The\x20time\x20the\x20experiment\
    \x20was\x20created.\x20In\x20seconds\x20since\x20the\x20UNIX\x20epoch.\n\
    \n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03>\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03>\t\x1a\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03>\x1d\x1e\n\
    L\n\x04\x04\0\x02\x04\x12\x03A\x02'\x1a?\x20Information\x20about\x20each\
    \x20hyperparameter\x20used\x20in\x20the\x20experiment.\n\n\x0c\n\x05\x04\
    \0\x02\x04\x04\x12\x03A\x02\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03A\x0b\
    \x15\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03A\x16\"\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03A%&\nD\n\x04\x04\0\x02\x05\x12\x03D\x02'\x1a7\x20Informa\
    tion\x20about\x20each\x20metric\x20used\x20in\x20the\x20experiment.\n\n\
    \x0c\n\x05\x04\0\x02\x05\x04\x12\x03D\x02\n\n\x0c\n\x05\x04\0\x02\x05\
    \x06\x12\x03D\x0b\x15\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03D\x16\"\n\x0c\
    \n\x05\x04\0\x02\x05\x03\x12\x03D%&\n\x19\n\x02\x04\x01\x12\x04H\0c\x01\
    \x1a\r\x20NEXT_TAG:\x207\n\n\n\n\x03\x04\x01\x01\x12\x03H\x08\x12\n,\n\
    \x04\x04\x01\x02\0\x12\x03J\x02\x12\x1a\x1f\x20An\x20id\x20for\x20the\
    \x20hyperparameter.\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03J\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03J\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03J\x10\x11\nv\n\x04\x04\x01\x02\x01\x12\x03N\x02\x1a\x1ai\x20A\
    \x20string\x20used\x20to\x20display\x20the\x20hyperparameter\x20in\x20th\
    e\x20UI.\x20If\x20empty,\x20the\x20UI\n\x20will\x20display\x20the\x20'na\
    me'\x20field.\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03N\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03N\t\x15\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03N\x18\x19\n3\n\x04\x04\x01\x02\x02\x12\x03Q\x02\x19\x1a&\x20A\
    \x20description.\x20May\x20contain\x20markdown.\n\n\x0c\n\x05\x04\x01\
    \x02\x02\x05\x12\x03Q\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03Q\t\
    \x14\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03Q\x17\x18\n4\n\x04\x04\x01\
    \x02\x03\x12\x03T\x02\x14\x1a'\x20The\x20data\x20type\x20of\x20this\x20h\
    yperparameter.\n\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03T\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x01\x12\x03T\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x03\
    \x03\x12\x03T\x12\x13\n\xa9\x03\n\x04\x04\x01\x08\0\x12\x04\\\x02b\x03\
    \x1a\x9a\x03\x20Specifies\x20the\x20set\x20of\x20values\x20this\x20hyper\
    parameter\x20can\x20hold.\x20The\x20UI\x20assumes\n\x20every\x20instance\
    \x20of\x20this\x20hyperparameter\x20will\x20hold\x20a\x20value\x20from\
    \x20this\x20set.\x20It\n\x20is\x20used\x20by\x20the\x20UI\x20to\x20allow\
    \x20filtering\x20so\x20that\x20only\x20session\x20groups\x20(see\n\x20be\
    low)\x20whose\x20associated\x20hyperparameter\x20value\x20\"passes\"\x20\
    the\x20filter\x20are\n\x20displayed.\x20If\x20this\x20is\x20not\x20popul\
    ated,\x20the\x20domain\x20is\x20assumed\x20to\x20be\x20the\n\x20entire\
    \x20domain\x20of\x20the\x20type\x20of\x20the\x20hyperparameter.\n\n\x0c\
    \n\x05\x04\x01\x08\0\x01\x12\x03\\\x08\x0e\nI\n\x04\x04\x01\x02\x04\x12\
    \x03^\x042\x1a<\x20A\x20discrete\x20set\x20of\x20the\x20values\x20this\
    \x20hyperparameter\x20can\x20hold.\n\n\x0c\n\x05\x04\x01\x02\x04\x06\x12\
    \x03^\x04\x1d\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03^\x1e-\n\x0c\n\x05\
    \x04\x01\x02\x04\x03\x12\x03^01\no\n\x04\x04\x01\x02\x05\x12\x03a\x04!\
    \x1ab\x20Numeric\x20data\x20type\x20only.\x20The\x20(real)\x20interval\
    \x20from\x20which\x20values\x20of\x20this\n\x20hyperparameter\x20are\x20\
    taken.\n\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03a\x04\x0c\n\x0c\n\x05\
    \x04\x01\x02\x05\x01\x12\x03a\r\x1c\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\
    \x03a\x1f\x20\n\n\n\x02\x05\0\x12\x04e\0j\x01\n\n\n\x03\x05\0\x01\x12\
    \x03e\x05\r\n\x0b\n\x04\x05\0\x02\0\x12\x03f\x02\x16\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03f\x02\x11\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03f\x14\x15\
    \n\x0b\n\x04\x05\0\x02\x01\x12\x03g\x02\x17\n\x0c\n\x05\x05\0\x02\x01\
    \x01\x12\x03g\x02\x12\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03g\x15\x16\n\
    \x0b\n\x04\x05\0\x02\x02\x12\x03h\x02\x15\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03h\x02\x10\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03h\x13\x14\n\x0b\n\
    \x04\x05\0\x02\x03\x12\x03i\x02\x18\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03i\x02\x13\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03i\x16\x17\nb\n\x02\
    \x04\x02\x12\x04n\0q\x01\x1aV\x20Represents\x20the\x20closed\x20interval\
    \x20[min_value,\x20max_value]\x20of\x20the\x20real\x20line.\n\x20NEXT_TA\
    G:\x203\n\n\n\n\x03\x04\x02\x01\x12\x03n\x08\x10\n\x0b\n\x04\x04\x02\x02\
    \0\x12\x03o\x02\x17\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03o\x02\x08\n\x0c\
    \n\x05\x04\x02\x02\0\x01\x12\x03o\t\x12\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03o\x15\x16\n\x0b\n\x04\x04\x02\x02\x01\x12\x03p\x02\x17\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03p\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03p\t\x12\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03p\x15\x16\n\
    \x1a\n\x02\x04\x03\x12\x05t\0\x92\x01\x01\x1a\r\x20NEXT_TAG:\x203\n\n\n\
    \n\x03\x04\x03\x01\x12\x03t\x08\x12\n\xb0\x0c\n\x04\x04\x03\x02\0\x12\
    \x04\x90\x01\x02\x13\x1a\xa1\x0c\x20An\x20identifier\x20for\x20a\x20metr\
    ic.\x20A\x20metric\x20is\x20a\x20real-valued\x20function\x20of\x20the\n\
    \x20model.\x20The\x20UI\x20can\x20plot\x20metrics\x20for\x20a\x20session\
    \x20evaluated\x20on\x20the\x20model\x20at\n\x20different\x20training\x20\
    steps.\n\n\x20We\x20identify\x20a\x20metric\x20by\x20a\x20(group,\x20tag\
    )\x20pair\x20of\x20strings.\x20The\x20UI\x20treats\n\x20both\x20of\x20th\
    ese\x20as\x20opaque\x20strings.\x20The\x20only\x20requirement\x20is\x20t\
    hat\x20the\x20pair\n\x20uniquely\x20identifies\x20a\x20metric\x20in\x20t\
    he\x20experiment.\n\n\x20We\x20use\x20a\x20pair\x20so\x20the\x20UI\x20co\
    uld\x20allow\x20the\x20user\x20to\x20group\x20metrics\x20for\x20a\n\x20s\
    ingle\x20session\x20by\x20either\x20group\x20or\x20tag\x20to\x20be\x20di\
    splayed\x20in\x20the\x20same\x20chart.\n\x20For\x20instance,\x20one\x20c\
    an\x20set\x20the\x20metric\x20group\x20to\x20correspond\x20to\x20the\x20\
    dataset\n\x20on\x20which\x20the\x20model\x20was\x20evaluated,\x20and\x20\
    the\x20UI\x20can\x20then\x20display\x20different\n\x20metrics\x20describ\
    ing\x20the\x20same\x20underlying\x20computation\x20and\x20using\x20diffe\
    rent\n\x20datasets,\x20on\x20the\x20same\x20chart.\n\n\x20When\x20export\
    ing\x20summaries\x20from\x20Tensorflow,\x20in\x20a\x20typical\x20setup,\
    \x20a\n\x20training\x20session\x20exports\x20evaluations\x20of\x20metric\
    s\x20at\x20different\x20training\x20steps\n\x20as\x20Scalar-plugin\x20su\
    mmaries--each\x20having\x20a\x20run\x20of\x20the\x20form\n\x20\"<session\
    _base_log_dir>/<sub_dir>\",\x20and\x20some\x20associated\x20tag.\x20The\
    \x20same\n\x20metric\x20for\x20different\x20sessions\x20would\x20use\x20\
    the\x20same\x20sub_dir\x20and\x20tag,\x20but\n\x20would\x20have\x20a\x20\
    different\x20session_base_log_dir.\x20For\x20example,\x20a\x20session\n\
    \x20computing\x20two\x20metrics:\x20model\x20loss\x20on\x20the\x20valida\
    tion\x20set\x20and\x20model\x20loss\x20on\n\x20the\x20training\x20set,\
    \x20can\x20export\x20these\x20as\x20scalar\x20summaries\x20with\x20the\
    \x20tag\x20\"loss\"\n\x20and\x20runs\x20session_base_log_dir/validation\
    \x20and\x20session_base_log_dir/training,\n\x20respectively.\x20In\x20th\
    is\x20setup,\x20the\x20'group'\x20field\x20can\x20be\x20populated\x20wit\
    h\n\x20the\x20\"sub_dir\"\x20associated\x20with\x20the\x20metric,\x20and\
    \x20the\x20'tag'\x20field\x20can\x20be\n\x20populated\x20with\x20the\x20\
    tag:\x20\"loss\".\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x90\x01\x02\x08\
    \n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x90\x01\t\x0e\n\r\n\x05\x04\x03\x02\
    \0\x03\x12\x04\x90\x01\x11\x12\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\x91\
    \x01\x02\x11\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\x91\x01\x02\x08\n\r\n\
    \x05\x04\x03\x02\x01\x01\x12\x04\x91\x01\t\x0c\n\r\n\x05\x04\x03\x02\x01\
    \x03\x12\x04\x91\x01\x0f\x10\n\x1b\n\x02\x04\x04\x12\x06\x95\x01\0\xa1\
    \x01\x01\x1a\r\x20NEXT_TAG:\x206\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x95\
    \x01\x08\x12\n\x0c\n\x04\x04\x04\x02\0\x12\x04\x96\x01\x02\x16\n\r\n\x05\
    \x04\x04\x02\0\x06\x12\x04\x96\x01\x02\x0c\n\r\n\x05\x04\x04\x02\0\x01\
    \x12\x04\x96\x01\r\x11\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x96\x01\x14\
    \x15\no\n\x04\x04\x04\x02\x01\x12\x04\x9a\x01\x02\x1a\x1aa\x20A\x20strin\
    g\x20used\x20to\x20display\x20the\x20metric\x20in\x20the\x20UI.\x20If\
    \x20empty,\x20the\x20UI\n\x20will\x20display\x20the\x20'name'\x20field.\
    \n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\x9a\x01\x02\x08\n\r\n\x05\x04\
    \x04\x02\x01\x01\x12\x04\x9a\x01\t\x15\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\x9a\x01\x18\x19\n4\n\x04\x04\x04\x02\x02\x12\x04\x9d\x01\x02\x19\
    \x1a&\x20A\x20description.\x20May\x20contain\x20markdown.\n\n\r\n\x05\
    \x04\x04\x02\x02\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\x04\x02\x02\
    \x01\x12\x04\x9d\x01\t\x14\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x9d\x01\
    \x17\x18\nX\n\x04\x04\x04\x02\x03\x12\x04\xa0\x01\x02\x1f\x1aJ\x20The\
    \x20dataset\x20type\x20(validation,\x20training)\x20on\x20which\x20the\
    \x20metric\x20is\x20computed.\n\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\
    \xa0\x01\x02\r\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xa0\x01\x0e\x1a\n\r\
    \n\x05\x04\x04\x02\x03\x03\x12\x04\xa0\x01\x1d\x1e\n\x0c\n\x02\x05\x01\
    \x12\x06\xa3\x01\0\xa7\x01\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xa3\x01\
    \x05\x10\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xa4\x01\x02\x16\n\r\n\x05\x05\
    \x01\x02\0\x01\x12\x04\xa4\x01\x02\x11\n\r\n\x05\x05\x01\x02\0\x02\x12\
    \x04\xa4\x01\x14\x15\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\xa5\x01\x02\x17\
    \n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xa5\x01\x02\x12\n\r\n\x05\x05\x01\
    \x02\x01\x02\x12\x04\xa5\x01\x15\x16\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\
    \xa6\x01\x02\x19\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xa6\x01\x02\x14\n\
    \r\n\x05\x05\x01\x02\x02\x02\x12\x04\xa6\x01\x17\x18\n\x93\x04\n\x02\x04\
    \x05\x12\x06\xb1\x01\0\xc5\x01\x01\x1a\x84\x04\x20In\x20some\x20experime\
    nts,\x20the\x20user\x20trains\x20a\x20model\x20with\x20the\x20same\x20se\
    t\x20of\n\x20hyperparameters\x20multiple\x20times\x20to\x20get\x20the\
    \x20distribution\x20of\x20metric\n\x20evaluations,\x20when\x20the\x20com\
    putation\x20(such\x20as\x20the\x20training\x20algorithm,\x20or\x20metric\
    \n\x20evaluation)\x20is\x20non-deterministic.\x20To\x20make\x20the\x20UI\
    \x20aware\x20of\x20this,\x20sessions\n\x20are\x20partitioned\x20into\x20\
    groups:\x20each\x20group\x20consists\x20of\x20all\x20training\x20session\
    s\n\x20which\x20share\x20the\x20same\x20values\x20for\x20the\x20hyperpar\
    ameters.\x20In\x20experiments\x20with\x20no\n\x20repeated\x20executions,\
    \x20each\x20group\x20consists\x20of\x20exactly\x20one\x20session.\n\x20N\
    EXT_TAG:\x206\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xb1\x01\x08\x14\n\x0c\n\
    \x04\x04\x05\x02\0\x12\x04\xb2\x01\x02\x12\n\r\n\x05\x04\x05\x02\0\x05\
    \x12\x04\xb2\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xb2\x01\t\r\
    \n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xb2\x01\x10\x11\n\x82\x01\n\x04\x04\
    \x05\x02\x01\x12\x04\xb6\x01\x02C\x1at\x20Stores\x20the\x20hyperparamete\
    rs\x20for\x20sessions\x20within\x20this\x20group\x20as\x20a\x20mapping\n\
    \x20from\x20the\x20hyperparameter\x20name\x20to\x20its\x20value.\n\n\r\n\
    \x05\x04\x05\x02\x01\x06\x12\x04\xb6\x01\x026\n\r\n\x05\x04\x05\x02\x01\
    \x01\x12\x04\xb6\x017>\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xb6\x01AB\n\
    \x87\x03\n\x04\x04\x05\x02\x02\x12\x04\xbe\x01\x02)\x1a\xf8\x02\x20A\x20\
    list\x20of\x20pairs\x20(metric,\x20value)--one\x20for\x20each\x20metric\
    \x20in\x20the\x20experiment.\n\x20The\x20value\x20denotes\x20the\x20eval\
    uation\x20of\x20the\x20corresponding\x20metric\x20on\n\x20the\x20model\
    \x20aggregated\x20across\x20the\x20sessions\x20in\x20this\x20group.\x20T\
    he\x20exact\x20method\n\x20of\x20aggregation\x20is\x20specified\x20in\
    \x20the\x20comments\x20of\x20ListSessionGroupsRequest.\n\x20Unfortunatel\
    y,\x20we\x20can't\x20store\x20these\x20as\x20a\x20map,\x20since\x20proto\
    \x20maps\x20can't\x20have\n\x20message\x20keys.\n\n\r\n\x05\x04\x05\x02\
    \x02\x04\x12\x04\xbe\x01\x02\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\xbe\
    \x01\x0b\x16\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xbe\x01\x17$\n\r\n\
    \x05\x04\x05\x02\x02\x03\x12\x04\xbe\x01'(\n5\n\x04\x04\x05\x02\x03\x12\
    \x04\xc1\x01\x02\x20\x1a'\x20The\x20sessions\x20belonging\x20to\x20this\
    \x20group.\n\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\xc1\x01\x02\n\n\r\n\
    \x05\x04\x05\x02\x03\x06\x12\x04\xc1\x01\x0b\x12\n\r\n\x05\x04\x05\x02\
    \x03\x01\x12\x04\xc1\x01\x13\x1b\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\
    \xc1\x01\x1e\x1f\nL\n\x04\x04\x05\x02\x04\x12\x04\xc4\x01\x02\x19\x1a>\
    \x20An\x20optional\x20link\x20to\x20a\x20web\x20page\x20monitoring\x20th\
    e\x20session\x20group.\n\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\xc4\x01\
    \x02\x08\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\xc4\x01\t\x14\n\r\n\x05\
    \x04\x05\x02\x04\x03\x12\x04\xc4\x01\x17\x18\n\x1b\n\x02\x04\x06\x12\x06\
    \xc8\x01\0\xd2\x01\x01\x1a\r\x20NEXT_TAG:\x205\n\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\xc8\x01\x08\x13\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xc9\x01\x02\
    \x16\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xc9\x01\x02\x0c\n\r\n\x05\x04\
    \x06\x02\0\x01\x12\x04\xc9\x01\r\x11\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \xc9\x01\x14\x15\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xcb\x01\x02\x13\n\r\
    \n\x05\x04\x06\x02\x01\x05\x12\x04\xcb\x01\x02\x08\n\r\n\x05\x04\x06\x02\
    \x01\x01\x12\x04\xcb\x01\t\x0e\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xcb\
    \x01\x11\x12\nB\n\x04\x04\x06\x02\x02\x12\x04\xce\x01\x02\x1a\x1a4\x20Th\
    e\x20training\x20step\x20at\x20which\x20this\x20value\x20is\x20computed.\
    \n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xce\x01\x02\x07\n\r\n\x05\x04\
    \x06\x02\x02\x01\x12\x04\xce\x01\x08\x15\n\r\n\x05\x04\x06\x02\x02\x03\
    \x12\x04\xce\x01\x18\x19\nZ\n\x04\x04\x06\x02\x03\x12\x04\xd1\x01\x02\
    \x1c\x1aL\x20The\x20wall\x20time\x20in\x20seconds\x20since\x20UNIX\x20ep\
    och\x20at\x20which\x20this\x20value\x20is\x20computed.\n\n\r\n\x05\x04\
    \x06\x02\x03\x05\x12\x04\xd1\x01\x02\x08\n\r\n\x05\x04\x06\x02\x03\x01\
    \x12\x04\xd1\x01\t\x17\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xd1\x01\x1a\
    \x1b\n\x1b\n\x02\x04\x07\x12\x06\xd5\x01\0\xf0\x01\x01\x1a\r\x20NEXT_TAG\
    :\x208\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xd5\x01\x08\x0f\nX\n\x04\x04\
    \x07\x02\0\x12\x04\xd7\x01\x02\x12\x1aJ\x20An\x20id\x20for\x20the\x20ses\
    sion.\x20Unique\x20within\x20an\x20experiment\x20(not\x20just\x20the\x20\
    group).\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xd7\x01\x02\x08\n\r\n\x05\
    \x04\x07\x02\0\x01\x12\x04\xd7\x01\t\r\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xd7\x01\x10\x11\n0\n\x04\x04\x07\x02\x01\x12\x04\xda\x01\x02\x1d\
    \x1a\"\x20In\x20seconds\x20since\x20the\x20UNIX\x20epoch.\n\n\r\n\x05\
    \x04\x07\x02\x01\x05\x12\x04\xda\x01\x02\x08\n\r\n\x05\x04\x07\x02\x01\
    \x01\x12\x04\xda\x01\t\x18\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xda\x01\
    \x1b\x1c\nn\n\x04\x04\x07\x02\x02\x12\x04\xde\x01\x02\x1b\x1a`\x20In\x20\
    seconds\x20since\x20the\x20UNIX\x20epoch.\n\x20May\x20be\x200\x20if\x20u\
    navailable\x20or\x20the\x20session\x20has\x20not\x20finished\x20yet.\n\n\
    \r\n\x05\x04\x07\x02\x02\x05\x12\x04\xde\x01\x02\x08\n\r\n\x05\x04\x07\
    \x02\x02\x01\x12\x04\xde\x01\t\x16\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\
    \xde\x01\x19\x1a\n5\n\x04\x04\x07\x02\x03\x12\x04\xe1\x01\x02\x14\x1a'\
    \x20May\x20be\x20STATUS_UNKNOWN\x20if\x20unavailable.\n\n\r\n\x05\x04\
    \x07\x02\x03\x06\x12\x04\xe1\x01\x02\x08\n\r\n\x05\x04\x07\x02\x03\x01\
    \x12\x04\xe1\x01\t\x0f\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xe1\x01\x12\
    \x13\n\xa5\x02\n\x04\x04\x07\x02\x04\x12\x04\xe7\x01\x02\x17\x1a\x96\x02\
    \x20A\x20URI\x20for\x20a\x20resource\x20that\x20will\x20allow\x20the\x20\
    user\x20to\x20reconstruct\x20the\x20model\x20for\n\x20this\x20session.\
    \x20E.g.,\x20in\x20Tensorflow\x20this\x20could\x20point\x20to\x20a\x20di\
    rectory\x20where\x20the\n\x20checkpoints\x20are\x20stored.\x20Currently,\
    \x20this\x20is\x20treated\x20opaquely\x20by\x20the\x20UI\n\x20and\x20onl\
    y\x20displayed\x20to\x20the\x20user\x20as\x20it\x20is\x20passed\x20here.\
    \n\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xe7\x01\x02\x08\n\r\n\x05\x04\
    \x07\x02\x04\x01\x12\x04\xe7\x01\t\x12\n\r\n\x05\x04\x07\x02\x04\x03\x12\
    \x04\xe7\x01\x15\x16\n\xb3\x01\n\x04\x04\x07\x02\x05\x12\x04\xec\x01\x02\
    )\x1a\xa4\x01\x20Stores\x20each\x20metric\x20evaluation\x20on\x20the\x20\
    model\x20at\x20the\x20current\x20training\x20step.\n\x20Unfortunately,\
    \x20we\x20can't\x20store\x20these\x20as\x20a\x20map,\x20since\x20proto\
    \x20maps\x20can't\x20have\n\x20message\x20keys.\n\n\r\n\x05\x04\x07\x02\
    \x05\x04\x12\x04\xec\x01\x02\n\n\r\n\x05\x04\x07\x02\x05\x06\x12\x04\xec\
    \x01\x0b\x16\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\xec\x01\x17$\n\r\n\
    \x05\x04\x07\x02\x05\x03\x12\x04\xec\x01'(\nF\n\x04\x04\x07\x02\x06\x12\
    \x04\xef\x01\x02\x19\x1a8\x20An\x20optional\x20link\x20to\x20a\x20web\
    \x20page\x20monitoring\x20the\x20session.\n\n\r\n\x05\x04\x07\x02\x06\
    \x05\x12\x04\xef\x01\x02\x08\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\xef\
    \x01\t\x14\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\xef\x01\x17\x18\n3\n\
    \x02\x05\x02\x12\x06\xf3\x01\0\xf8\x01\x01\x1a%\x20Represents\x20the\x20\
    status\x20of\x20a\x20Session.\n\n\x0b\n\x03\x05\x02\x01\x12\x04\xf3\x01\
    \x05\x0b\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xf4\x01\x02\x15\n\r\n\x05\x05\
    \x02\x02\0\x01\x12\x04\xf4\x01\x02\x10\n\r\n\x05\x05\x02\x02\0\x02\x12\
    \x04\xf4\x01\x13\x14\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xf5\x01\x02\x15\
    \n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xf5\x01\x02\x10\n\r\n\x05\x05\x02\
    \x02\x01\x02\x12\x04\xf5\x01\x13\x14\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\
    \xf6\x01\x02\x15\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xf6\x01\x02\x10\n\
    \r\n\x05\x05\x02\x02\x02\x02\x12\x04\xf6\x01\x13\x14\n\x0c\n\x04\x05\x02\
    \x02\x03\x12\x04\xf7\x01\x02\x15\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\
    \xf7\x01\x02\x10\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\xf7\x01\x13\x14\n\
    w\n\x02\x04\x08\x12\x06\xfd\x01\0\x80\x02\x01\x1ai\x20Parameters\x20for\
    \x20a\x20GetExperiment\x20API\x20call.\n\x20Each\x20experiment\x20is\x20\
    scoped\x20by\x20a\x20unique\x20global\x20id.\n\x20NEXT_TAG:\x202\n\n\x0b\
    \n\x03\x04\x08\x01\x12\x04\xfd\x01\x08\x1c\n\x18\n\x04\x04\x08\x02\0\x12\
    \x04\xff\x01\x02\x1d\x1a\n\x20REQUIRED\n\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\xff\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xff\x01\t\x18\n\
    \r\n\x05\x04\x08\x02\0\x03\x12\x04\xff\x01\x1b\x1c\n\x8c\x02\n\x02\x04\t\
    \x12\x06\x87\x02\0\xb8\x02\x01\x1a\xfd\x01\x20Parameters\x20for\x20a\x20\
    ListSessionGroups\x20API\x20call.\n\x20Computes\x20a\x20list\x20of\x20th\
    e\x20current\x20session\x20groups\x20allowing\x20for\x20filtering\x20and\
    \n\x20sorting\x20by\x20metrics\x20and\x20hyperparameter\x20values.\x20Re\
    turns\x20a\x20\"slice\"\x20of\n\x20that\x20list\x20specified\x20by\x20st\
    art_index\x20and\x20slice_size.\n\x20NEXT_TAG:\x208\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\x87\x02\x08\x20\n\x0c\n\x04\x04\t\x02\0\x12\x04\x88\x02\x02\
    \x1d\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x88\x02\x02\x08\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\x88\x02\t\x18\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x88\
    \x02\x1b\x1c\n\xa9\x01\n\x04\x04\t\x02\x01\x12\x04\x8d\x02\x02'\x1a\x9a\
    \x01\x20Filters\x20the\x20set\x20of\x20sessions\x20(from\x20which\x20the\
    \x20session\x20groups\x20are\x20formed)\x20to\n\x20contain\x20only\x20th\
    ese\x20sessions\x20whose\x20status\x20is\x20contained\x20in\n\x20'allowe\
    d_statuses'.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\x8d\x02\x02\n\n\r\n\
    \x05\x04\t\x02\x01\x06\x12\x04\x8d\x02\x0b\x11\n\r\n\x05\x04\t\x02\x01\
    \x01\x12\x04\x8d\x02\x12\"\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8d\x02%&\
    \n\x8f\x05\n\x04\x04\t\x02\x02\x12\x04\x9a\x02\x02$\x1a\x80\x05\x20A\x20\
    list\x20of\x20ColParams\x20messages--one\x20for\x20each\x20\"column\"\
    \x20of\x20a\x20session\x20group.\x20A\n\x20session\x20group\x20column\
    \x20contains\x20either\x20a\x20metric\x20evaluated\x20at\x20the\x20curre\
    nt\n\x20reported\x20computation\x20step\x20or\x20a\x20hyperparameter\x20\
    value.\x20In\x20addition\x20to\n\x20'regular'\x20values,\x20a\x20column\
    \x20may\x20take\x20on\x20a\x20special\x20'missing-value'\x20which\n\x20d\
    enotes\x20that\x20the\x20hyperparameter\x20or\x20metric\x20is\x20not\x20\
    available\n\x20for\x20the\x20session\x20group\x20(for\x20example,\x20if\
    \x20the\x20metric\x20is\x20not\x20used\x20in\x20the\n\x20group).\n\n\x20\
    The\x20ColParams\x20messages\x20in\x20the\x20repeated\x20field\x20below\
    \x20configure\x20filtering\x20and\n\x20sorting\x20of\x20the\x20resulting\
    \x20collection\x20of\x20session\x20groups.\x20See\x20the\x20comments\x20\
    of\n\x20the\x20fields\x20in\x20the\x20ColParam\x20message\x20below\x20fo\
    r\x20more\x20details.\n\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\x9a\x02\x02\
    \n\n\r\n\x05\x04\t\x02\x02\x06\x12\x04\x9a\x02\x0b\x14\n\r\n\x05\x04\t\
    \x02\x02\x01\x12\x04\x9a\x02\x15\x1f\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \x9a\x02\"#\n\x84\x05\n\x04\x04\t\x02\x03\x12\x04\xa7\x02\x02'\x1a\xf5\
    \x04\x20Fields\x20controlling\x20how\x20to\x20aggregate\x20metrics\x20ac\
    ross\x20sessions\x20within\x20a\n\x20session\x20group.\n\x20If\x20aggreg\
    ation_type\x20is\x20AGGREGATION_AVG,\x20each\x20metric\x20value\x20of\
    \x20the\n\x20session\x20group\x20is\x20the\x20average\x20of\x20the\x20va\
    lues\x20of\x20the\x20metric\x20across\x20the\n\x20sessions.\n\x20Otherwi\
    se,\x20the\x20session\x20group\x20metric\x20values\x20are\x20taken\x20di\
    rectly\x20from\x20a\n\x20\"representative\"\x20session\x20in\x20the\x20g\
    roup,\x20selected\x20as\x20a\x20session\x20for\x20which\n\x20primary_met\
    ric\x20takes\x20on\x20its\x20minimum,\x20maximum,\x20or\x20median\x20val\
    ue,\x20as\n\x20specified\x20by\x20the\x20choice\x20of\x20aggregation_typ\
    e\x20(for\x20median,\x20if\x20the\x20number\x20of\n\x20sessions\x20in\
    \x20the\x20group\x20is\x20even,\x20a\x20session\x20with\x20a\x20lower\
    \x20\"middle\"\x20value\x20is\n\x20chosen\x20as\x20the\x20representative\
    \x20session).\n\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xa7\x02\x02\x11\n\r\
    \n\x05\x04\t\x02\x03\x01\x12\x04\xa7\x02\x12\"\n\r\n\x05\x04\t\x02\x03\
    \x03\x12\x04\xa7\x02%&\n9\n\x04\x04\t\x02\x04\x12\x04\xaa\x02\x02$\x1a+\
    \x20See\x20comment\x20for\x20'aggregation_type'\x20above.\n\n\r\n\x05\
    \x04\t\x02\x04\x06\x12\x04\xaa\x02\x02\x0c\n\r\n\x05\x04\t\x02\x04\x01\
    \x12\x04\xaa\x02\r\x1f\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xaa\x02\"#\n\
    \xd4\x01\n\x04\x04\t\x02\x05\x12\x04\xaf\x02\x02\x18\x1a\xc5\x01\x20The\
    \x20next\x20two\x20parameters\x20determine\x20the\x20\"slice\"\x20of\x20\
    the\x20full\x20list\x20of\n\x20session\x20groups--sorted\x20and\x20filte\
    red\x20by\x20the\x20parameters\x20above--to\x20return.\n\x20The\x200-bas\
    ed\x20index\x20of\x20the\x20first\x20session\x20group\x20to\x20return.\n\
    \n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xaf\x02\x02\x07\n\r\n\x05\x04\t\x02\
    \x05\x01\x12\x04\xaf\x02\x08\x13\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xaf\
    \x02\x16\x17\n\xfb\x02\n\x04\x04\t\x02\x06\x12\x04\xb7\x02\x02\x17\x1a\
    \xec\x02\x20The\x20number\x20of\x20session\x20groups\x20to\x20return\x20\
    starting\x20at\x20the\x20session\x20group\n\x20indexed\x20by\x20'start_i\
    ndex'.\x20The\x20actual\x20number\x20of\x20session\x20groups\x20returned\
    \n\x20is\x20min{slice_size,\x20total_size\x20-\x20start_index},\x20where\
    \n\x20total_size\x20is\x20the\x20number\x20of\x20session\x20groups\x20in\
    \x20the\x20full\x20list\n\x20sorted\x20and\x20filtered\x20by\x20the\x20p\
    arameters\x20above\x20(if\x20start_index\x20>\x20total_size\n\x20no\x20s\
    ession\x20groups\x20are\x20returned).\n\n\r\n\x05\x04\t\x02\x06\x05\x12\
    \x04\xb7\x02\x02\x07\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\xb7\x02\x08\x12\
    \n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xb7\x02\x15\x16\n\xad\x01\n\x02\x04\
    \n\x12\x06\xbd\x02\0\xed\x02\x01\x1a\x9e\x01\x20Defines\x20parmeters\x20\
    for\x20a\x20ListSessionGroupsRequest\x20for\x20a\x20specific\x20column.\
    \n\x20See\x20the\x20comment\x20for\x20\"ListSessionGroupsRequest\"\x20ab\
    ove\x20for\x20more\x20details.\n\x20NEXT_TAG:\x209\n\n\x0b\n\x03\x04\n\
    \x01\x12\x04\xbd\x02\x08\x11\n\x0e\n\x04\x04\n\x08\0\x12\x06\xbe\x02\x02\
    \xc1\x02\x03\n\r\n\x05\x04\n\x08\0\x01\x12\x04\xbe\x02\x08\x0c\n\x0c\n\
    \x04\x04\n\x02\0\x12\x04\xbf\x02\x04\x1a\n\r\n\x05\x04\n\x02\0\x06\x12\
    \x04\xbf\x02\x04\x0e\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xbf\x02\x0f\x15\n\
    \r\n\x05\x04\n\x02\0\x03\x12\x04\xbf\x02\x18\x19\n\x0c\n\x04\x04\n\x02\
    \x01\x12\x04\xc0\x02\x04\x16\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xc0\x02\
    \x04\n\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xc0\x02\x0b\x11\n\r\n\x05\x04\
    \n\x02\x01\x03\x12\x04\xc0\x02\x14\x15\n\xc1\x06\n\x04\x04\n\x02\x02\x12\
    \x04\xd1\x02\x02\x16\x1a\xb2\x06\x20Sorting.\n\x20The\x20final\x20order\
    \x20of\x20session\x20groups\x20in\x20the\x20response\x20is\x20defined\
    \x20by\x20the\x20sub\n\x20collection\x20of\x20ColParams\x20messages\x20(\
    out\x20of\x20the\n\x20ListSessionGroupsRequest.col_params\x20repeated\
    \x20field)\x20whose\x20'order'\x20field\n\x20(below)\x20is\x20not\x20ORD\
    ER_UNSPECIFIED.\x20In\x20each\x20of\x20the\x20messages\x20in\x20this\n\
    \x20sub-collection,\x20the\x20next\x20two\x20fields\x20specify\x20the\
    \x20ordering\x20of\x20the\x20values\n\x20and\x20missing_values\x20in\x20\
    the\x20associated\x20column\x20of\x20the\x20session\x20group.\x20The\n\
    \x20order\x20of\x20the\x20ColParams\x20messages\x20themselves\x20within\
    \x20the\x20sub-collection\n\x20determines\x20the\x20\"significance\"\x20\
    of\x20the\x20associated\x20column\x20as\x20a\x20sorting\x20key:\n\x20wit\
    h\x20the\x20first\x20being\x20the\x20primary\x20sorting\x20key,\x20the\
    \x20second\x20being\x20the\n\x20secondary\x20sorting\x20key,\x20etc.\n\
    \x20Note:\x20The\x20'session\x20group\x20name'\x20is\x20added\x20as\x20a\
    \x20least\x20significant\x20sorting\n\x20key\x20to\x20the\x20keys\x20def\
    ined\x20by\x20the\x20user,\x20so\x20the\x20order\x20in\x20the\x20respons\
    e\x20is\x20always\n\x20deterministic.\n\n\r\n\x05\x04\n\x02\x02\x06\x12\
    \x04\xd1\x02\x02\x0b\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xd1\x02\x0c\x11\
    \n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xd1\x02\x14\x15\n\xe0\x01\n\x04\x04\
    \n\x02\x03\x12\x04\xd6\x02\x02\x20\x1a\xd1\x01\x20This\x20field\x20is\
    \x20ignored\x20if\x20order\x20is\x20ORDER_UNSPECIFIED.\n\x20Otherwise,\
    \x20if\x20true,\x20missing\x20values\x20are\x20ordered\x20before\x20ever\
    y\x20other\x20value\x20in\n\x20the\x20column;\x20if\x20false\x20they\x20\
    are\x20ordered\x20after\x20every\x20other\x20value\x20in\x20the\n\x20col\
    umn.\n\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xd6\x02\x02\x06\n\r\n\x05\x04\
    \n\x02\x03\x01\x12\x04\xd6\x02\x07\x1b\n\r\n\x05\x04\n\x02\x03\x03\x12\
    \x04\xd6\x02\x1e\x1f\n\xb6\x02\n\x04\x04\n\x08\x01\x12\x06\xdd\x02\x02\
    \xe9\x02\x03\x1a\xa5\x02\x20Filtering.\n\x20The\x20'filter'\x20oneof\x20\
    specifies\x20a\x20subset\x20of\x20the\x20domain\x20of\x20the\x20values\
    \x20a\x20column\n\x20may\x20take.\x20Only\x20session\x20groups\x20with\
    \x20each\x20of\x20their\x20column\x20values\x20belonging\n\x20to\x20this\
    \x20subset\x20are\x20included\x20in\x20the\x20response.\x20If\x20this\
    \x20field\x20is\x20not\n\x20specified,\x20the\x20subset\x20is\x20taken\
    \x20to\x20be\x20the\x20entire\x20column\x20domain.\n\n\r\n\x05\x04\n\x08\
    \x01\x01\x12\x04\xdd\x02\x08\x0e\n\xeb\x01\n\x04\x04\n\x02\x04\x12\x04\
    \xe2\x02\x04\x1d\x1a\xdc\x01\x20Only\x20valid\x20for\x20string-valued\
    \x20hyperparameter\x20columns.\x20The\x20subset\x20is\n\x20the\x20set\
    \x20of\x20all\x20strings\x20matching\x20the\x20regular\x20expression\x20\
    stored\n\x20in\x20'regexp'\x20as\x20a\x20partial\x20match\x20(use\x20'^<\
    regexp>$'\x20to\x20have\x20a\x20full\n\x20match\x20against\x20regexp).\n\
    \n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xe2\x02\x04\n\n\r\n\x05\x04\n\x02\
    \x04\x01\x12\x04\xe2\x02\x0b\x18\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xe2\
    \x02\x1b\x1c\nX\n\x04\x04\n\x02\x05\x12\x04\xe5\x02\x04!\x1aJ\x20Only\
    \x20valid\x20for\x20numeric-valued\x20columns.\x20The\x20subset\x20is\
    \x20the\x20given\x20interval.\n\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\xe5\
    \x02\x04\x0c\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xe5\x02\r\x1c\n\r\n\x05\
    \x04\n\x02\x05\x03\x12\x04\xe5\x02\x1f\x20\nK\n\x04\x04\n\x02\x06\x12\
    \x04\xe8\x02\x042\x1a=\x20Valid\x20for\x20all\x20data\x20types.\x20The\
    \x20subset\x20is\x20defined\x20explicitly.\n\n\r\n\x05\x04\n\x02\x06\x06\
    \x12\x04\xe8\x02\x04\x1d\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\xe8\x02\x1e\
    -\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\xe8\x0201\nm\n\x04\x04\n\x02\x07\
    \x12\x04\xec\x02\x02\"\x1a_\x20Specifies\x20whether\x20to\x20exclude\x20\
    session\x20groups\x20whose\x20column\x20value\x20is\x20missing\n\x20from\
    \x20the\x20response.\n\n\r\n\x05\x04\n\x02\x07\x05\x12\x04\xec\x02\x02\
    \x06\n\r\n\x05\x04\n\x02\x07\x01\x12\x04\xec\x02\x07\x1d\n\r\n\x05\x04\n\
    \x02\x07\x03\x12\x04\xec\x02\x20!\n\x0c\n\x02\x05\x03\x12\x06\xef\x02\0\
    \xf3\x02\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\xef\x02\x05\x0e\n\x0c\n\x04\
    \x05\x03\x02\0\x12\x04\xf0\x02\x02\x18\n\r\n\x05\x05\x03\x02\0\x01\x12\
    \x04\xf0\x02\x02\x13\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\xf0\x02\x16\x17\
    \n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xf1\x02\x02\x10\n\r\n\x05\x05\x03\
    \x02\x01\x01\x12\x04\xf1\x02\x02\x0b\n\r\n\x05\x05\x03\x02\x01\x02\x12\
    \x04\xf1\x02\x0e\x0f\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xf2\x02\x02\x11\
    \n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xf2\x02\x02\x0c\n\r\n\x05\x05\x03\
    \x02\x02\x02\x12\x04\xf2\x02\x0f\x10\n\x0c\n\x02\x05\x04\x12\x06\xf5\x02\
    \0\xfb\x02\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\xf5\x02\x05\x14\n\x0c\n\
    \x04\x05\x04\x02\0\x12\x04\xf6\x02\x02\x18\n\r\n\x05\x05\x04\x02\0\x01\
    \x12\x04\xf6\x02\x02\x13\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\xf6\x02\x16\
    \x17\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xf7\x02\x02\x16\n\r\n\x05\x05\
    \x04\x02\x01\x01\x12\x04\xf7\x02\x02\x11\n\r\n\x05\x05\x04\x02\x01\x02\
    \x12\x04\xf7\x02\x14\x15\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xf8\x02\x02\
    \x19\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xf8\x02\x02\x14\n\r\n\x05\x05\
    \x04\x02\x02\x02\x12\x04\xf8\x02\x17\x18\n\x0c\n\x04\x05\x04\x02\x03\x12\
    \x04\xf9\x02\x02\x16\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xf9\x02\x02\
    \x11\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xf9\x02\x14\x15\n\x0c\n\x04\
    \x05\x04\x02\x04\x12\x04\xfa\x02\x02\x16\n\r\n\x05\x05\x04\x02\x04\x01\
    \x12\x04\xfa\x02\x02\x11\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xfa\x02\
    \x14\x15\nB\n\x02\x04\x0b\x12\x06\xff\x02\0\x87\x03\x01\x1a4\x20See\x20L\
    istSessionGroups\x20in\x20http_api.md.\n\x20NEXT_TAG:\x204\n\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\xff\x02\x08!\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x80\
    \x03\x02+\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\x80\x03\x02\n\n\r\n\x05\
    \x04\x0b\x02\0\x06\x12\x04\x80\x03\x0b\x17\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\x80\x03\x18&\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x80\x03)*\n\
    \xef\x01\n\x04\x04\x0b\x02\x01\x12\x04\x86\x03\x02\x17\x1a\xe0\x01\x20De\
    notes\x20the\x20total\x20number\x20of\x20session\x20groups\x20in\x20the\
    \x20full\x20filtered\x20list.\n\x20(Recall\x20that\x20this\x20response\
    \x20may\x20only\x20be\x20a\x20slice).\n\x20It\x20is\x20used\x20by\x20the\
    \x20UI\x20to\x20calculate\x20total\x20number\x20of\x20pages\x20and\x20ca\
    n\x20be\n\x20set\x20here\x20to\x20-1\x20to\x20mean\x20\"unknown\".\n\n\r\
    \n\x05\x04\x0b\x02\x01\x05\x12\x04\x86\x03\x02\x07\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\x86\x03\x08\x12\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \x86\x03\x15\x16\nG\n\x02\x04\x0c\x12\x06\x8b\x03\0\x8f\x03\x01\x1a9\x20\
    See\x20ListMetricEvalsRequest\x20in\x20http_api.md.\n\x20NEXT_TAG:\x204\
    \n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8b\x03\x08\x1e\n\x0c\n\x04\x04\x0c\
    \x02\0\x12\x04\x8c\x03\x02\x1d\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x8c\
    \x03\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x8c\x03\t\x18\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x8c\x03\x1b\x1c\n\x0c\n\x04\x04\x0c\x02\x01\
    \x12\x04\x8d\x03\x02\x1a\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x8d\x03\
    \x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x8d\x03\t\x15\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\x8d\x03\x18\x19\n\x0c\n\x04\x04\x0c\x02\x02\
    \x12\x04\x8e\x03\x02\x1d\n\r\n\x05\x04\x0c\x02\x02\x06\x12\x04\x8e\x03\
    \x02\x0c\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x8e\x03\r\x18\n\r\n\x05\
    \x04\x0c\x02\x02\x03\x12\x04\x8e\x03\x1b\x1cb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
